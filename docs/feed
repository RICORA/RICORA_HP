<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ja">
  <title>banbooooのブログ</title>
  
  <subtitle>統計、機械学習、数学に関する記事を投稿します。</subtitle>
  
  <link href="http://banboooo.hatenablog.com/"/>
  <updated>2018-10-14T03:58:36+09:00</updated>
  <author>
    <name>banboooo</name>
  </author>
  <generator uri="http://blog.hatena.ne.jp/" version="69c77a9ed747d8a2a64f576576c06136">Hatena::Blog</generator>
  <id>hatenablog://blog/17391345971618068544</id>

  
    
    
    <entry>
        <title>AGC028 B問題 Removing Blocks</title>
        <link href="http://banboooo.hatenablog.com/entry/2018/10/14/035836"/>
        <id>hatenablog://entry/10257846132652684945</id>
        <published>2018-10-14T03:58:36+09:00</published>
        <updated>2019-11-09T00:20:52+09:00</updated>        <summary type="html">AGC028のB問題 Removing Blocks</summary>
        <content type="html">&lt;p&gt;&lt;iframe src=&quot;https://hatenablog-parts.com/embed?url=https%3A%2F%2Fbeta.atcoder.jp%2Fcontests%2Fagc028%2Ftasks%2Fagc028_b&quot; title=&quot;B - Removing Blocks&quot; class=&quot;embed-card embed-webcard&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;&quot;&gt;&lt;/iframe&gt;&lt;cite class=&quot;hatena-citation&quot;&gt;&lt;a href=&quot;https://beta.atcoder.jp/contests/agc028/tasks/agc028_b&quot;&gt;beta.atcoder.jp&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;

&lt;p&gt;editorialで確率がどうのこうの書いてあって ??? となったので。&lt;/p&gt;

&lt;h1&gt;方針&lt;/h1&gt;

&lt;p&gt;最終的に求めたい答えは当たり前だけど &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20a_0%20A_0%20%2B%20a_1%20A_1%20%2B%20%5Ccdots%20%2B%20a_n%20A_n&quot; alt=&quot; a_0 A_0 + a_1 A_1 + \cdots + a_n A_n&quot;/&gt; の形でかける.
&lt;br&gt;そして , &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20a_i%20&quot; alt=&quot; a_i &quot;/&gt; の値を求めにいく.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20%20a_i%20%3D%20%5Cdisplaystyle%20%5Csum_%7Bj%7D%20%28%20A_j%20%E3%82%92%E5%8F%96%E3%82%8A%E9%99%A4%E3%81%8F%E6%99%82%E3%81%ABA_i%E3%81%8C%E9%80%A3%E7%B5%90%E3%81%A7%E3%81%82%E3%82%8B%E5%A0%B4%E5%90%88%E3%81%AE%E6%95%B0%20%29%20%20&quot; alt=&quot;  a_i = \displaystyle \sum_{j} ( A_j &amp;#x3092;&amp;#x53D6;&amp;#x308A;&amp;#x9664;&amp;#x304F;&amp;#x6642;&amp;#x306B;A_i&amp;#x304C;&amp;#x9023;&amp;#x7D50;&amp;#x3067;&amp;#x3042;&amp;#x308B;&amp;#x5834;&amp;#x5408;&amp;#x306E;&amp;#x6570; )  &quot;/&gt;
で求めること.&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20A_j%20&quot; alt=&quot; A_j &quot;/&gt;を取り除く時に&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=A_i&quot; alt=&quot;A_i&quot;/&gt;が連結である場合の数を全体の &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20N%21%20&quot; alt=&quot; N! &quot;/&gt; 通りの中の割合で求めること.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;この二つが大きなポイントだと思う. 二つ目の方から考える.&lt;/p&gt;

&lt;h1&gt;2つ目のポイントの考察&lt;/h1&gt;

&lt;p&gt;※下記では&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20j%20%5Cleq%20i%20&quot; alt=&quot; j \leq i &quot;/&gt;として議論する.
&lt;br&gt;&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20A_j%20&quot; alt=&quot; A_j &quot;/&gt;を取り除く時に&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=A_i&quot; alt=&quot;A_i&quot;/&gt;が連結である &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20%5CLeftrightarrow%20&quot; alt=&quot; \Leftrightarrow &quot;/&gt; &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20A_j%20%2C%20%5Ccdots%20%2C%20A_i%20&quot; alt=&quot; A_j , \cdots , A_i &quot;/&gt; 間で&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20A_j&quot; alt=&quot; A_j&quot;/&gt;が最初に除かれる.
&lt;br&gt;と言い換えることができる.では,その場合の数はN!のうちどのくらいの割合なのか?&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20A_j%20%5Ccdots%20A_i%20&quot; alt=&quot; A_j \cdots A_i &quot;/&gt;間で,初めて取り除かれるものを&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20A_k&quot; alt=&quot; A_k&quot;/&gt;とし , これによって事象を定義する.
&lt;br&gt;すなわち , 全事象 &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20%5COmega%20%3D%20%5Cdisplaystyle%20%5Cbigcup_%7Bk%3Dj%7D%5Ei%20%20%20%5Cleft%5C%7B%20%E4%BA%8B%E8%B1%A1k%20%3B%20A_j%20%5Ccdots%20A_i%20%E9%96%93%E3%81%A7A_k%E3%81%8C%E5%88%9D%E3%82%81%E3%81%A6%E9%99%A4%E3%81%8B%E3%82%8C%E3%82%8B%20%5Cright%5C%7D%20&quot; alt=&quot; \Omega = \displaystyle \bigcup_{k=j}^i   \left\{ &amp;#x4E8B;&amp;#x8C61;k ; A_j \cdots A_i &amp;#x9593;&amp;#x3067;A_k&amp;#x304C;&amp;#x521D;&amp;#x3081;&amp;#x3066;&amp;#x9664;&amp;#x304B;&amp;#x308C;&amp;#x308B; \right\} &quot;/&gt;
&lt;br&gt; これらは排反の事象であり , 確率(場合の数の割合)はどの事象も等しく &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20P%28k%29%20%3D%20%5Cdfrac%7B1%7D%7Bi%20-%20j%20%2B%201%7D&quot; alt=&quot; P(k) = \dfrac{1}{i - j + 1}&quot;/&gt; となっている.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=A_j&quot; alt=&quot;A_j&quot;/&gt;が最初に除かれる場合の数を知りたかったので, 全体の場合の数をかけて&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20N%21%20P%28j%29%20%3D%20%5Cdfrac%7BN%21%7D%7Bi%20-%20j%20%2B%201%7D%20&quot; alt=&quot; N! P(j) = \dfrac{N!}{i - j + 1} &quot;/&gt; &lt;/center&gt;


&lt;p&gt;あと , &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20j%20%5Cleq%20i%20&quot; alt=&quot; j \leq i &quot;/&gt; と条件を取っ払えば&lt;/p&gt;

&lt;center&gt; &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20N%21%20P%28j%29%20%3D%20%5Cdfrac%7BN%21%7D%7B%7Ci%20-%20j%7C%20%2B%201%7D%20&quot; alt=&quot; N! P(j) = \dfrac{N!}{|i - j| + 1} &quot;/&gt; &lt;/center&gt;


&lt;h1&gt;1つ目のポイントの考察&lt;/h1&gt;

&lt;p&gt;あとはさっきの結果を代入してあげればok&lt;/p&gt;

&lt;center&gt; &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20a_i%20%3D%20%5Cdisplaystyle%20%5Csum_%7Bj%7D%20%20%5Cdfrac%7BN%21%7D%7B%7Ci%20-%20j%7C%2B%201%7D%20&quot; alt=&quot; a_i = \displaystyle \sum_{j}  \dfrac{N!}{|i - j|+ 1} &quot;/&gt; &lt;/center&gt;


&lt;p&gt;最後にもう一工夫.
&lt;br&gt;&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20%200%20%5Cleq%20%7Ci-j%7C%20%5Cleq%20N%20&quot; alt=&quot;  0 \leq |i-j| \leq N &quot;/&gt; より , &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20%5Cdisplaystyle%20%5Csum_%7Bk%20%3D%200%7D%5EN%20%5Cdfrac%7BN%21%7D%7Bk%2B%201%7D%20&quot; alt=&quot; \displaystyle \sum_{k = 0}^N \dfrac{N!}{k+ 1} &quot;/&gt; を先に計算(累積和)しておくことができる. &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20O%28N%29&quot; alt=&quot; O(N)&quot;/&gt;
&lt;br&gt;すると &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20a_i%20&quot; alt=&quot; a_i &quot;/&gt; が&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20O%281%29&quot; alt=&quot; O(1)&quot;/&gt;で求まるようになる.&lt;/p&gt;

&lt;p&gt;なので,全体は答え  &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20a_0%20A_i%20%2B%20a_1%20A_1%20%2B%20%5Ccdots%20%2B%20a_n%20A_n&quot; alt=&quot; a_0 A_i + a_1 A_1 + \cdots + a_n A_n&quot;/&gt; は &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20O%28N%29&quot; alt=&quot; O(N)&quot;/&gt;で求まる.&lt;/p&gt;

&lt;h1&gt;&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9&quot;&gt;ソースコード&lt;/a&gt;&lt;/h1&gt;

&lt;pre class=&quot;code lang-python&quot; data-lang=&quot;python&quot; data-unlink&gt;N = &lt;span class=&quot;synIdentifier&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;input&lt;/span&gt;())
A = &lt;span class=&quot;synIdentifier&quot;&gt;list&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;map&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;int&lt;/span&gt;,&lt;span class=&quot;synIdentifier&quot;&gt;input&lt;/span&gt;().split(&lt;span class=&quot;synConstant&quot;&gt;&amp;quot; &amp;quot;&lt;/span&gt;)))
mod = &lt;span class=&quot;synConstant&quot;&gt;10&lt;/span&gt;**&lt;span class=&quot;synConstant&quot;&gt;9&lt;/span&gt;+&lt;span class=&quot;synConstant&quot;&gt;7&lt;/span&gt;

&lt;span class=&quot;synComment&quot;&gt;# N!計算&lt;/span&gt;
fact = &lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;synStatement&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;synStatement&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;synConstant&quot;&gt;2&lt;/span&gt;,N+&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;):
    fact *= i
    fact %= mod

&lt;span class=&quot;synComment&quot;&gt;# 場合の数計算&lt;/span&gt;
rev = [ (&lt;span class=&quot;synIdentifier&quot;&gt;pow&lt;/span&gt;((i),mod-&lt;span class=&quot;synConstant&quot;&gt;2&lt;/span&gt;,mod)*fact)%mod &lt;span class=&quot;synStatement&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;synStatement&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;,N+&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;) ]
&lt;span class=&quot;synComment&quot;&gt;# 累積和&lt;/span&gt;
&lt;span class=&quot;synStatement&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;synStatement&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;range&lt;/span&gt;(N-&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;):
    rev[i+&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;] += rev[i]
    rev[i+&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;] %= mod

&lt;span class=&quot;synComment&quot;&gt;# a_0 A_0 + a_1 A_1 + ... + a_n A_n を計算&lt;/span&gt;
ans = &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;synStatement&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;synStatement&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;range&lt;/span&gt;(N):
    ans += A[i] * (rev[i] + rev[N-&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;-i] - rev[&lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;]) % mod
    ans %= mod

&lt;span class=&quot;synIdentifier&quot;&gt;print&lt;/span&gt;(ans)
&lt;/pre&gt;


&lt;h1&gt;感想&lt;/h1&gt;

&lt;p&gt;解けてから見ると問題文にわざわざ&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20N%21&quot; alt=&quot; N!&quot;/&gt;通りとか書いてくれてるのはヒントだったのかなぁと思ったり。&lt;/p&gt;
</content>        
        <category term="競技プログラミング" label="競技プログラミング" />
        
        <link rel="enclosure" href="https://cdn.user.blog.st-hatena.com/default_entry_og_image/151453641/151961971911337" type="" length="0" />

        <author>
            <name>banboooo</name>
        </author>
    </entry>
    
  
    
    
    <entry>
        <title>ARC102 D問題 All Your Paths are Different Lengths</title>
        <link href="http://banboooo.hatenablog.com/entry/2018/09/02/142917"/>
        <id>hatenablog://entry/10257846132618727314</id>
        <published>2018-09-02T14:29:17+09:00</published>
        <updated>2019-12-29T19:48:08+09:00</updated>        <summary type="html">なんか最近難化傾向にあるような... D - All Your Paths are Different Lengths 1. 以下のようにノード 間に長さ の二つの辺を貼ると , の時のグラフが表現できる. 2. をサイズが2の累乗の区間の和で表すことを考える. ( ルール : サイズの大きい区間から貪欲に決めていくこと ) 例1 : 例2 : これと同じようにグラフをそれぞれ作ると ... こうすると , 同じ長さのパスを一つも作ることなく , グラフを構築することができました . pythonでの実装 L = int(input()) # ノード数を決める for i in range(1…</summary>
        <content type="html">&lt;p&gt;なんか最近難化傾向にあるような...&lt;br /&gt;
&lt;a href=&quot;https://beta.atcoder.jp/contests/arc102/tasks/arc102_b&quot;&gt;D - All Your Paths are Different Lengths&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;考察&gt;&lt;br /&gt;
   1. 以下のようにノード &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20n%20%2C%20m%20&quot; alt=&quot; n , m &quot;/&gt; 間に長さ &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%200%20%2C%202%5E%7Bn%7D%20&quot; alt=&quot; 0 , 2^{n} &quot;/&gt; の二つの辺を貼ると , &lt;br /&gt;
　&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20L%20%3D%202%20%5E%20%7Bnode%7D&quot; alt=&quot; L = 2 ^ {node}&quot;/&gt; の時のグラフが表現できる.&lt;/p&gt;&lt;p&gt;&lt;span itemscope itemtype=&quot;http://schema.org/Photograph&quot;&gt;&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/b/banboooo/20180902/20180902143647.jpg&quot; alt=&quot;f:id:banboooo:20180902143647j:plain:w300&quot; title=&quot;f:id:banboooo:20180902143647j:plain:w300&quot; class=&quot;hatena-fotolife&quot; style=&quot;width:300px&quot; itemprop=&quot;image&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;   2. &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20%5B%200%20%2C%20L%20%29&quot; alt=&quot; [ 0 , L )&quot;/&gt; をサイズが2の累乗の&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%B6%E8%B4%D6&quot;&gt;区間&lt;/a&gt;の和で表すことを考える.&lt;br /&gt;
　　( ルール : サイズの大きい&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%B6%E8%B4%D6&quot;&gt;区間&lt;/a&gt;から貪欲に決めていくこと )&lt;/p&gt;&lt;p&gt;　　例1 : &lt;br /&gt;
　　　&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20%5B0%20%2C%2010%29%20%3D%20%20%5B0%20%2C%208%29%20%5C%20%20%5Cbigcup%20%5C%20%5B8%20%2C%2010%29%20%5C%5C%20%0A%E3%80%80%E3%80%80%E3%80%80%3D%20%5B0%20%2C%208%20%29%5C%20%20%5Cbigcup%20%5C%20%20%5B%208%20%2B%200%20%2C%208%20%2B%202%20%29%20&quot; alt=&quot; [0 , 10) =  [0 , 8) \  \bigcup \ [8 , 10) \\ 
&amp;#x3000;&amp;#x3000;&amp;#x3000;= [0 , 8 )\  \bigcup \  [ 8 + 0 , 8 + 2 ) &quot;/&gt;&lt;br /&gt;
　　例2 :&lt;br /&gt;
　　　&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20%5B0%20.%2015%29%20%3D%20%20%5B0%20%2C%208%29%5C%20%20%5Cbigcup%20%5C%20%20%5B8%20%2C%2012%29%20%5C%20%20%5Cbigcup%20%5C%20%5B12%20%2C%2014%29%20%5C%20%5Cbigcup%20%5C%20%5B14%20%2C%2015%29%20%5C%5C%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3D%20%5B0%20%2C%208%29%20%5C%20%5Cbigcup%20%5C%20%5B%208%20%2B%200%20%2C%208%20%2B%204%20%29%20%5C%20%5Cbigcup%20%5C%20%5B%2012%20%2B%200%20%2C%2012%20%2B%202%20%29%20%5C%20%5Cbigcup%20%5C%20%5B%2014%20%2B%200%20%2C%2014%20%2B%201%20%29%20&quot; alt=&quot; [0 . 15) =  [0 , 8)\  \bigcup \  [8 , 12) \  \bigcup \ [12 , 14) \ \bigcup \ [14 , 15) \\ 
                                = [0 , 8) \ \bigcup \ [ 8 + 0 , 8 + 4 ) \ \bigcup \ [ 12 + 0 , 12 + 2 ) \ \bigcup \ [ 14 + 0 , 14 + 1 ) &quot;/&gt;&lt;/p&gt;&lt;p&gt;　　これと同じようにグラフをそれぞれ作ると ... &lt;br /&gt;
&lt;span itemscope itemtype=&quot;http://schema.org/Photograph&quot;&gt;&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/b/banboooo/20180902/20180902152739.jpg&quot; alt=&quot;f:id:banboooo:20180902152739j:plain:w500&quot; title=&quot;f:id:banboooo:20180902152739j:plain:w500&quot; class=&quot;hatena-fotolife&quot; style=&quot;width:500px&quot; itemprop=&quot;image&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;こうすると , 同じ長さのパスを一つも作ることなく , グラフを構築することができました .&lt;br /&gt;
&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/python&quot;&gt;python&lt;/a&gt;での実装&lt;/p&gt;
&lt;pre class=&quot;code lang-python&quot; data-lang=&quot;python&quot; data-unlink&gt;L = &lt;span class=&quot;synIdentifier&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;input&lt;/span&gt;())
&lt;span class=&quot;synComment&quot;&gt;# ノード数を決める&lt;/span&gt;
&lt;span class=&quot;synStatement&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;synStatement&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;synConstant&quot;&gt;21&lt;/span&gt;):
    &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; i) &amp;gt; L:
        node = i
        &lt;span class=&quot;synStatement&quot;&gt;break&lt;/span&gt;

&lt;span class=&quot;synComment&quot;&gt;# 必ず 0と2^Nの辺を貼る&lt;/span&gt;
edge = []
&lt;span class=&quot;synStatement&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;synStatement&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;range&lt;/span&gt;(node-&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;):
    edge.append((i+&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;,i+&lt;span class=&quot;synConstant&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;))
    edge.append((i+&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;,i+&lt;span class=&quot;synConstant&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;&amp;lt;&amp;lt;i))

&lt;span class=&quot;synComment&quot;&gt;# 2の累乗の区間に分割&lt;/span&gt;
&lt;span class=&quot;synStatement&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;synStatement&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;range&lt;/span&gt;(node-&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;):
    &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; (L &amp;gt;&amp;gt; i) &amp;amp; &lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;:
        edge.append((i+&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;,node,L-(&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;&amp;lt;&amp;lt;i)))
        L = L-(&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;&amp;lt;&amp;lt;i)

&lt;span class=&quot;synComment&quot;&gt;#出力&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;str&lt;/span&gt;(dig) + &lt;span class=&quot;synConstant&quot;&gt;&amp;quot; &amp;quot;&lt;/span&gt; + &lt;span class=&quot;synIdentifier&quot;&gt;str&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;len&lt;/span&gt;(edge)))
s = &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;{0} {1} {2}&amp;quot;&lt;/span&gt;
&lt;span class=&quot;synStatement&quot;&gt;for&lt;/span&gt; v,v2,w &lt;span class=&quot;synStatement&quot;&gt;in&lt;/span&gt; edge:
    &lt;span class=&quot;synIdentifier&quot;&gt;print&lt;/span&gt;(s.format(v,v2,w))
&lt;/pre&gt;&lt;p&gt;&lt;br /&gt;
　　&lt;br /&gt;
　　&lt;/p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;p&gt;    &lt;/p&gt;
</content>        
        <category term="競技プログラミング" label="競技プログラミング" />
        
        <link rel="enclosure" href="https://cdn.user.blog.st-hatena.com/default_entry_og_image/151453641/151961971911337" type="" length="0" />

        <author>
            <name>banboooo</name>
        </author>
    </entry>
    
  
    
    
    <entry>
        <title>RSA暗号のpython実装</title>
        <link href="http://banboooo.hatenablog.com/entry/2018/07/12/162800"/>
        <id>hatenablog://entry/10257846132600489016</id>
        <published>2018-07-12T16:28:00+09:00</published>
        <updated>2018-08-01T00:47:59+09:00</updated>        <summary type="html">競プロとは関係ないですが。授業で聞いて面白かったので実装してみました。 アルゴリズムの解説(準備) 素数 を決める (十分大きな数) を求め、 と互いに素な数 を1つランダムに選ぶ。 となる を求める。( の特殊解を求めることと同値 ) (暗号化) 平文 (数字) に対し、暗号 は で求める。(復号化) 暗号 (数字) に対し、元の平文 は で求める。(全体像) 公開鍵は、 と である。 が十分に大きい時、 から を求めることが現実的でないことを利用している。 from random import randint class RSA: def __init__(self,p1,p2): sel…</summary>
        <content type="html">&lt;p&gt;競プロとは関係ないですが。授業で聞いて面白かったので実装してみました。&lt;br /&gt;
&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0&quot;&gt;アルゴリズム&lt;/a&gt;の解説&lt;/p&gt;&lt;p&gt;(準備)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%C1%C7%BF%F4&quot;&gt;素数&lt;/a&gt; &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20p1%2Cp2&quot; alt=&quot; p1,p2&quot;/&gt;   を決める (十分大きな数)&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20L%20%3D%20lcm%28p1-1%2Cp2-1%29%20&quot; alt=&quot; L = lcm(p1-1,p2-1) &quot;/&gt;   を求め、&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=L&quot; alt=&quot;L&quot;/&gt; と互いに素な数  &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20e%20&quot; alt=&quot; e &quot;/&gt; を1つランダムに選ぶ。&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20e%20x%20%5Cequiv%201%20%28mod%20L%20%29%20&quot; alt=&quot; e x \equiv 1 (mod L ) &quot;/&gt;   となる   &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20x%20%28%20x%20%3E%200%29&quot; alt=&quot; x ( x &amp;gt; 0)&quot;/&gt;   を求める。( &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20ex%20%2B%20Ly%20%3D%201&quot; alt=&quot; ex + Ly = 1&quot;/&gt; の特殊解を求めることと同値 )&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;(暗号化)&lt;br /&gt;
平文 &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20S&quot; alt=&quot; S&quot;/&gt; (数字) に対し、暗号 &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20C&quot; alt=&quot; C&quot;/&gt; は   &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20%20C%20%3D%20S%5Ee%20%28mod%20%5C%20p1%5Ctimes%20p2%29%20&quot; alt=&quot;  C = S^e (mod \ p1\times p2) &quot;/&gt;    で求める。&lt;/p&gt;&lt;p&gt;(復号化)&lt;br /&gt;
暗号 &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20C&quot; alt=&quot; C&quot;/&gt; (数字) に対し、元の平文 &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20S&quot; alt=&quot; S&quot;/&gt; は   &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20C%5E%7Bx%7D%20%28mod%20%5C%20p1%5Ctimes%20p2%29&quot; alt=&quot; C^{x} (mod \ p1\times p2)&quot;/&gt;    で求める。&lt;/p&gt;&lt;p&gt;(全体像)&lt;br /&gt;
公開鍵は、&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20p1%20%5Ctimes%20p2%20&quot; alt=&quot; p1 \times p2 &quot;/&gt; と &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20e&quot; alt=&quot; e&quot;/&gt; である。&lt;br /&gt;
&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20p1%20%2C%20p2%20&quot; alt=&quot; p1 , p2 &quot;/&gt; が十分に大きい時、&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20p1%20%5Ctimes%20p2&quot; alt=&quot; p1 \times p2&quot;/&gt; から &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20p1%20%2C%20p2&quot; alt=&quot; p1 , p2&quot;/&gt;を求めることが現実的でないことを利用している。&lt;/p&gt;
&lt;pre class=&quot;code lang-python&quot; data-lang=&quot;python&quot; data-unlink&gt;&lt;span class=&quot;synPreProc&quot;&gt;from&lt;/span&gt; random &lt;span class=&quot;synPreProc&quot;&gt;import&lt;/span&gt; randint
&lt;span class=&quot;synStatement&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;RSA&lt;/span&gt;:
	&lt;span class=&quot;synStatement&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;__init__&lt;/span&gt;(self,p1,p2):
		self.__p1,self.__p2,self.__d,self.e,self.n = self.__makeKey(p1,p2)

	&lt;span class=&quot;synStatement&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;__gcd&lt;/span&gt; (self,a,b):
		&lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; a &amp;lt; b:
			a,b = b,a
		&lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; a &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; b == &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;else&lt;/span&gt; self.__gcd(b,a%b)

	&lt;span class=&quot;synStatement&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;__lcm&lt;/span&gt; (self,a,b):
		&lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; a*b//self.__gcd(a,b)

	&lt;span class=&quot;synStatement&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;__extended_euclid&lt;/span&gt;(self,a,b,k = &lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;):
		&lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; k != &lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;:
			g = self.__gcd(a,b)
			a //= g
			b //= g

		cc = gg = &lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;
		ee = ff = &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;
		&lt;span class=&quot;synStatement&quot;&gt;while&lt;/span&gt; b:
			div,mod = &lt;span class=&quot;synIdentifier&quot;&gt;divmod&lt;/span&gt;(a,b)
			hh = cc - div * ee
			ii = ff - div * gg
			a,b = b,mod
			cc,ee = ee,hh
			ff,gg = gg,ii

		&lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; (cc,ff)

	&lt;span class=&quot;synStatement&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;__choose_e&lt;/span&gt;(self,n,e = &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;):
		&lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; e != &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;:
			&lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; e
		&lt;span class=&quot;synStatement&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;True&lt;/span&gt;:
			k = randint(n+&lt;span class=&quot;synConstant&quot;&gt;100&lt;/span&gt;,n+&lt;span class=&quot;synConstant&quot;&gt;1000&lt;/span&gt;)
			&lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; self.__gcd(k,n) == &lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;:
				&lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; k

	&lt;span class=&quot;synStatement&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;__makeKey&lt;/span&gt; (self,p1,p2):
		n = p1*p2
		l = self.__lcm(p1-&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;,p2-&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;)
		e = self.__choose_e(l)
		(d,se) = self.__extended_euclid(e,l)
		&lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; d &amp;lt;= &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;:
			d += l 
		&lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; p1,p2,d,e,n

        &lt;span class=&quot;synComment&quot;&gt;# 暗号化(数字)&lt;/span&gt;
	&lt;span class=&quot;synStatement&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;encode&lt;/span&gt; (self,x):
		&lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; x &amp;gt; self.n:
			&lt;span class=&quot;synIdentifier&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;x must be under {0}&amp;quot;&lt;/span&gt;.forat(self.n))
			exit(&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;)
		&lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;pow&lt;/span&gt;(x,self.e,self.n)
       &lt;span class=&quot;synComment&quot;&gt;# 復号化(数字)&lt;/span&gt;
	&lt;span class=&quot;synStatement&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;decode&lt;/span&gt; (self,c):
		&lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;pow&lt;/span&gt;(c,self.__d,self.n)
       &lt;span class=&quot;synComment&quot;&gt;# 暗号化(文字)&lt;/span&gt;
	&lt;span class=&quot;synStatement&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;encode_str&lt;/span&gt; (self,s):
		ret = []
		&lt;span class=&quot;synStatement&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;synStatement&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;len&lt;/span&gt;(s)):
			ret.append(self.encode(&lt;span class=&quot;synIdentifier&quot;&gt;ord&lt;/span&gt;(s[i])))
		&lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; ret
        &lt;span class=&quot;synComment&quot;&gt;# 復号化(文字)&lt;/span&gt;
	&lt;span class=&quot;synStatement&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;decode_str&lt;/span&gt; (self,s):
		ret = []
		&lt;span class=&quot;synStatement&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;synStatement&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;synIdentifier&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;synIdentifier&quot;&gt;len&lt;/span&gt;(s)):
			ret.append(&lt;span class=&quot;synIdentifier&quot;&gt;chr&lt;/span&gt;(self.decode(s[i])))
		&lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;.join(ret)
&lt;/pre&gt;&lt;p&gt;実行例&lt;/p&gt;
&lt;pre class=&quot;code lang-python&quot; data-lang=&quot;python&quot; data-unlink&gt;A = RSA(&lt;span class=&quot;synConstant&quot;&gt;149&lt;/span&gt;,&lt;span class=&quot;synConstant&quot;&gt;151&lt;/span&gt;) &lt;span class=&quot;synComment&quot;&gt;# 149 と 151&lt;/span&gt;

&lt;span class=&quot;synComment&quot;&gt;# 公開鍵&lt;/span&gt;
&lt;span class=&quot;synIdentifier&quot;&gt;print&lt;/span&gt; (A.e,A.n)

&lt;span class=&quot;synComment&quot;&gt;# 数字の暗号化&lt;/span&gt;
Code = A.encode(&lt;span class=&quot;synConstant&quot;&gt;57&lt;/span&gt;)
&lt;span class=&quot;synIdentifier&quot;&gt;print&lt;/span&gt;(Code)

&lt;span class=&quot;synComment&quot;&gt;#数字の復号化&lt;/span&gt;
Raw = A.decode(Code)
&lt;span class=&quot;synIdentifier&quot;&gt;print&lt;/span&gt;(Raw) &lt;span class=&quot;synComment&quot;&gt;# 57に戻る&lt;/span&gt;

&lt;span class=&quot;synComment&quot;&gt;#文字の暗号化&lt;/span&gt;
Code = A.encode_str(&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;Hello&amp;quot;&lt;/span&gt;)
&lt;span class=&quot;synIdentifier&quot;&gt;print&lt;/span&gt;(Code)

&lt;span class=&quot;synComment&quot;&gt;#文字の復号化&lt;/span&gt;
Raw = A.decode_str(Code)
&lt;span class=&quot;synIdentifier&quot;&gt;print&lt;/span&gt;(Raw) &lt;span class=&quot;synComment&quot;&gt;# &amp;quot;Hello&amp;quot;に戻る&lt;/span&gt;
&lt;/pre&gt;</content>        
        <link rel="enclosure" href="https://chart.apis.google.com/chart?cht=tx&amp;chl=%20p1%2Cp2" type="" length="0" />

        <author>
            <name>banboooo</name>
        </author>
    </entry>
    
  
    
    
    <entry>
        <title>ARC100 E問題 OrPlusMax (高速ゼータ変換)</title>
        <link href="http://banboooo.hatenablog.com/entry/2018/07/02/224251"/>
        <id>hatenablog://entry/10257846132597487165</id>
        <published>2018-07-02T22:42:51+09:00</published>
        <updated>2019-11-09T00:31:39+09:00</updated>        <summary type="html">E - Or Plus Max 高速ゼータ変換の問題。といっても貼るだけの問題ではなく、集合や演算を自分で考察してうまくテンプレに落としてやる必要がある。 また、やってることはbitDPなので言葉を知らなくても解ける(僕はコンテスト中には解けてない) この記事では、どこの部分がいわゆる高速ゼータ変換のテンプレになっているかを書いておく。 そもそも高速ゼータ変換とは ? こちらの記事を参考にさせていただきました。 https://topcoder.g.hatena.ne.jp/iwiwi/20120422/1335065228 高速ゼータ変換 集合に対する関数 に対し、全集合 に対して、 これを…</summary>
        <content type="html">&lt;p&gt;&lt;a href=&quot;https://beta.atcoder.jp/contests/arc100/tasks/arc100_c&quot;&gt;E - Or Plus Max&lt;/a&gt;&lt;br /&gt;
高速ゼータ変換の問題。といっても貼るだけの問題ではなく、集合や演算を自分で考察してうまくテンプレに落としてやる必要がある。&lt;br /&gt;
また、やってることはbitDPなので言葉を知らなくても解ける(僕はコンテスト中には解けてない)&lt;br /&gt;
この記事では、どこの部分がいわゆる高速ゼータ変換のテンプレになっているかを書いておく。&lt;br /&gt;
&lt;br /&gt;
&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;そもそも高速ゼータ変換とは ? &lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;こちらの記事を参考にさせていただきました。&lt;br /&gt;
&lt;a href=&quot;https://topcoder.g.hatena.ne.jp/iwiwi/20120422/1335065228&quot;&gt;https://topcoder.g.hatena.ne.jp/iwiwi/20120422/1335065228&lt;/a&gt;&lt;/p&gt;&lt;br /&gt;
&lt;p&gt;&lt;b&gt; 高速ゼータ変換&lt;br /&gt;
集合に対する関数 &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20f%28S%29&quot; alt=&quot; f(S)&quot;/&gt; に対し、全集合 &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20S&quot; alt=&quot; S&quot;/&gt; に対して、&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20g%28S%29%20%3D%20%5Csum_%7BS%20%5Csubseteq%20T%7D%20f%28T%29%20&quot; alt=&quot; g(S) = \sum_{S \subseteq T} f(T) &quot;/&gt; &lt;/b&gt;&lt;/p&gt;&lt;p&gt;これを実装したものが&lt;/p&gt;
&lt;pre class=&quot;code lang-cpp&quot; data-lang=&quot;cpp&quot; data-unlink&gt; rep (i, n) rep (b, &lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; n) &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; ((b &amp;amp; (&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; i)) == &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt; )  a[b] += a[b | (&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; i)];
&lt;/pre&gt;&lt;p&gt;と書けるそう。&lt;br /&gt;
&lt;br /&gt;
&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;本問ではどのように使われているのか ?&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;結論から先に言うと、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;集合 &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20S%20%3A%3D%20%5C%7B%20i%20%7C%20%E6%95%B0n%E3%81%AEi%E3%83%93%E3%83%83%E3%83%88%E7%9B%AE%E3%81%8C0%20%5C%7D%20&quot; alt=&quot; S := \{ i | &amp;#x6570;n&amp;#x306E;i&amp;#x30D3;&amp;#x30C3;&amp;#x30C8;&amp;#x76EE;&amp;#x304C;0 \} &quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;演算 &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20merge%20%3A%3D%201%E7%95%AA%E7%9B%AE%E3%81%AB%E5%A4%A7%E3%81%8D%E3%81%84%E6%95%B0%E3%81%A82%E7%95%AA%E7%9B%AE%E3%81%AB%E5%A4%A7%E3%81%8D%E3%81%84%E6%95%B0%E3%82%92%E6%9B%B4%E6%96%B0&quot; alt=&quot; merge := 1&amp;#x756A;&amp;#x76EE;&amp;#x306B;&amp;#x5927;&amp;#x304D;&amp;#x3044;&amp;#x6570;&amp;#x3068;2&amp;#x756A;&amp;#x76EE;&amp;#x306B;&amp;#x5927;&amp;#x304D;&amp;#x3044;&amp;#x6570;&amp;#x3092;&amp;#x66F4;&amp;#x65B0;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;と定義する。&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9&quot;&gt;ソースコード&lt;/a&gt;はこんな感じ。&lt;/p&gt;
&lt;pre class=&quot;code lang-cpp&quot; data-lang=&quot;cpp&quot; data-unlink&gt; rep (i, n) rep (b, &lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; n) &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; ((b &amp;amp; (&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; i)) == &lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt; )  
        a[b] = merge( a[b] , a[b ^ (&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; i)] );
&lt;/pre&gt;&lt;p&gt;( おまけ )&lt;br /&gt;
集合を&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20S%20%3A%3D%20%5C%7B%20i%20%7C%20%E6%95%B0n%E3%81%AEi%E3%83%93%E3%83%83%E3%83%88%E7%9B%AE%E3%81%8C1%20%5C%7D%20&quot; alt=&quot; S := \{ i | &amp;#x6570;n&amp;#x306E;i&amp;#x30D3;&amp;#x30C3;&amp;#x30C8;&amp;#x76EE;&amp;#x304C;1 \} &quot;/&gt;と取ることもできるが、&lt;br /&gt;
この時は &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20g%28S%29%20%3D%20%5Csum_%7BS%20%5Csupseteq%20T%7D%20f%28T%29%20&quot; alt=&quot; g(S) = \sum_{S \supseteq T} f(T) &quot;/&gt; になっており、&lt;br /&gt;
理解の足りない僕はあれ?包含関係逆じゃね ? いいの ? とか考えてしまった。&lt;br /&gt;
また、こちらの方針で実装する場合は以下のようになる。&lt;/p&gt;
&lt;pre class=&quot;code lang-cpp&quot; data-lang=&quot;cpp&quot; data-unlink&gt;&lt;span class=&quot;synStatement&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;synType&quot;&gt;int&lt;/span&gt; i = (n-&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;); i &amp;gt;= &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt; ; i-- )
    &lt;span class=&quot;synStatement&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;synType&quot;&gt;int&lt;/span&gt; b = (&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; n) - &lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt; ; b &amp;gt;=  &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt; ; b-- )
        &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; (!(b &amp;amp; (&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; i))) dp[b|(&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;&amp;lt;&amp;lt;i)] = merge(dp[b|(&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;&amp;lt;&amp;lt;i)],dp[b]);
&lt;/pre&gt;&lt;p&gt;ループの向きを逆にしないといけない。これは大いにバグの原因になりそう。&lt;br /&gt;
		&lt;br /&gt;
最後に僕のE問題の&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9&quot;&gt;ソースコード&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;code lang-cpp&quot; data-lang=&quot;cpp&quot; data-unlink&gt;&lt;span class=&quot;synComment&quot;&gt;//演算&lt;/span&gt;
&lt;span class=&quot;synPreProc&quot;&gt;#include &lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;
vector&amp;lt;&lt;span class=&quot;synType&quot;&gt;long&lt;/span&gt;&amp;gt; merge(vector&amp;lt;&lt;span class=&quot;synType&quot;&gt;long&lt;/span&gt;&amp;gt; &amp;amp;A,vector&amp;lt;&lt;span class=&quot;synType&quot;&gt;long&lt;/span&gt;&amp;gt; &amp;amp;B) {
	vector&amp;lt;&lt;span class=&quot;synType&quot;&gt;long&lt;/span&gt;&amp;gt; cp(A);
	REP(i,B.size()) cp.push_back(B[i]);
	sort((cp).begin(),(cp).end(),greater&amp;lt;&lt;span class=&quot;synType&quot;&gt;long&lt;/span&gt;&amp;gt;());
	&lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; vector&amp;lt;&lt;span class=&quot;synType&quot;&gt;long&lt;/span&gt;&amp;gt;(cp.begin(),cp.begin()+min(&lt;span class=&quot;synConstant&quot;&gt;2&lt;/span&gt;,(&lt;span class=&quot;synType&quot;&gt;int&lt;/span&gt;)cp.size()));
}

&lt;span class=&quot;synType&quot;&gt;int&lt;/span&gt; main(&lt;span class=&quot;synType&quot;&gt;void&lt;/span&gt;) {
	&lt;span class=&quot;synType&quot;&gt;int&lt;/span&gt; N;
	cin &amp;gt;&amp;gt; N;
	vector&amp;lt;&lt;span class=&quot;synType&quot;&gt;long&lt;/span&gt;&amp;gt; A(&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;&amp;lt;&amp;lt;N);
	&lt;span class=&quot;synStatement&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;synType&quot;&gt;long&lt;/span&gt; i = &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;;i &amp;lt; (&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;&amp;lt;&amp;lt;N);i++) cin &amp;gt;&amp;gt; A[i];
	vector&amp;lt;vector&amp;lt;&lt;span class=&quot;synType&quot;&gt;long&lt;/span&gt;&amp;gt;&amp;gt; dp(&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;&amp;lt;&amp;lt;N,vector&amp;lt;&lt;span class=&quot;synType&quot;&gt;long&lt;/span&gt;&amp;gt;(&lt;span class=&quot;synConstant&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;));
	&lt;span class=&quot;synStatement&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;synType&quot;&gt;long&lt;/span&gt; i = &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;;i &amp;lt; (&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;&amp;lt;&amp;lt;N);i++) dp[i] = {A[i]};

	&lt;span class=&quot;synComment&quot;&gt;/*ゼータ変換部分*/&lt;/span&gt;
	&lt;span class=&quot;synStatement&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;synType&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;;i &amp;lt; N;i++) REP(b,&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;&amp;lt;&amp;lt;N) &lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; ((b &amp;amp; (&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; i))) {
		dp[b] = merge(dp[b],dp[b ^ (&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; i)]);
	}

	&lt;span class=&quot;synType&quot;&gt;long&lt;/span&gt; ans = &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;;
	&lt;span class=&quot;synStatement&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;synType&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;;i &amp;lt; (&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;&amp;lt;&amp;lt;N);i++) {
		ans = max(ans,dp[i][&lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;]+dp[i][&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;]);
		cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
	}
}
&lt;/pre&gt;</content>        
        <category term="競技プログラミング" label="競技プログラミング" />
        
        <link rel="enclosure" href="https://chart.apis.google.com/chart?cht=tx&amp;chl=%20f%28S%29" type="" length="0" />

        <author>
            <name>banboooo</name>
        </author>
    </entry>
    
  
    
    
    <entry>
        <title>codeFlyer C問題 徒歩圏内</title>
        <link href="http://banboooo.hatenablog.com/entry/2018/06/03/025645"/>
        <id>hatenablog://entry/17391345971650507637</id>
        <published>2018-06-03T02:56:45+09:00</published>
        <updated>2019-11-09T00:31:56+09:00</updated>        <summary type="html">解けなくて悔しいので記事に。考察の流れとかも書いておく。 排反をとるというのがtwitterで見ててわかりやすそうだったので実装。bitflyer2018-qual.contest.atcoder.jp 考察した(ダメ)解法 1. : 左端と真ん中を決めて右端の数を二分探索で数える。左端と真ん中の決め方をしゃくとりできるかなと思ったが無理。通り試さないとだめ。当然TLE。2. 左端と右端を決めて、真ん中を二分探索で数える。1と本質的には変わらず。二分探索と累積和を使う 解法 正しい解法 左端の都市、真ん中の都市、右端の都市のindexをそれぞれ と書く。 全ての の組み合わせは、 通り ここか…</summary>
        <content type="html">&lt;p&gt;解けなくて悔しいので記事に。考察の流れとかも書いておく。&lt;br /&gt;
排反をとるというのが&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/twitter&quot;&gt;twitter&lt;/a&gt;で見ててわかりやすそうだったので実装。&lt;/p&gt;&lt;p&gt;&lt;iframe src=&quot;https://hatenablog-parts.com/embed?url=https%3A%2F%2Fbitflyer2018-qual.contest.atcoder.jp%2Ftasks%2Fbitflyer2018_qual_c&quot; title=&quot;C: 徒歩圏内 - codeFlyer （bitFlyer Programming Contest） | AtCoder&quot; class=&quot;embed-card embed-webcard&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;&quot;&gt;&lt;/iframe&gt;&lt;cite class=&quot;hatena-citation&quot;&gt;&lt;a href=&quot;https://bitflyer2018-qual.contest.atcoder.jp/tasks/bitflyer2018_qual_c&quot;&gt;bitflyer2018-qual.contest.atcoder.jp&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;&lt;br /&gt;
&lt;p&gt;&lt;b&gt;考察した(ダメ)解法&lt;/b&gt;&lt;br /&gt;
1. &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20O%28N%5E2%20%5Clog%20N%20%29&quot; alt=&quot; O(N^2 \log N )&quot;/&gt;  : 左端と真ん中を決めて右端の数を二分探索で数える。左端と真ん中の決め方をしゃくとりできるかなと思ったが無理。&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%7B%7D_n%20C%20_2&quot; alt=&quot;{}_n C _2&quot;/&gt;通り試さないとだめ。当然TLE。&lt;/p&gt;&lt;p&gt;2. 左端と右端を決めて、真ん中を二分探索で数える。1と本質的には変わらず。&lt;/p&gt;&lt;p&gt;&lt;b&gt;二分探索と累積和を使う &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=O%28N%20%5Clog%20N%29&quot; alt=&quot;O(N \log N)&quot;/&gt; 解法&lt;/b&gt;&lt;br /&gt;
&lt;b&gt;正しい解法&lt;/b&gt;&lt;br /&gt;
左端の都市、真ん中の都市、右端の都市のindexをそれぞれ &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20i%20%2C%20j%20%2C%20k%20%28%20i%20%3C%20j%20%3C%20k%20%29%20&quot; alt=&quot; i , j , k ( i &amp;lt; j &amp;lt; k ) &quot;/&gt; と書く。&lt;br /&gt;
全ての &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20%28%20i%20%2C%20j%20%2C%20k%20%29&quot; alt=&quot; ( i , j , k )&quot;/&gt; の組み合わせは、&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20%7B%7D_n%20C%20_3%20&quot; alt=&quot; {}_n C _3 &quot;/&gt; 通り&lt;br /&gt;
ここから条件に合わないものを引くことを考える。&lt;/p&gt;&lt;p&gt;左端の都市 &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20i%20&quot; alt=&quot; i &quot;/&gt; を順に見ていく。&lt;/p&gt;&lt;p&gt;1.  &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20%28X_j%20-%20X_i%29%20%3E%20D%20&quot; alt=&quot; (X_j - X_i) &amp;gt; D &quot;/&gt;  の場合 -&gt;  &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20%7B%7D_%28X_i%E3%81%8B%E3%82%89%E5%8F%B3%E3%81%ABD%E3%82%88%E3%82%8A%E9%9B%A2%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E9%83%BD%E5%B8%82%E6%95%B0%29%20C%20_2&quot; alt=&quot; {}_(X_i&amp;#x304B;&amp;#x3089;&amp;#x53F3;&amp;#x306B;D&amp;#x3088;&amp;#x308A;&amp;#x96E2;&amp;#x308C;&amp;#x3066;&amp;#x3044;&amp;#x308B;&amp;#x90FD;&amp;#x5E02;&amp;#x6570;) C _2&quot;/&gt; 通り&lt;br /&gt;
真ん中が左端からDより離れている場合、右端も左端からDより離れている。&lt;br /&gt;
よって、(左端から右にDより離れている都市) の中から2つ選ぶ組み合わせに対応する。&lt;/p&gt;&lt;p&gt;2.  &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20%28X_%20j%20-%20X_i%20%29%20%5Cleqq%20D%20%E3%81%8B%E3%81%A4%20%28%20X_k%20-%20X_j%20%29%20%3E%20D&quot; alt=&quot; (X_ j - X_i ) \leqq D &amp;#x304B;&amp;#x3064; ( X_k - X_j ) &amp;gt; D&quot;/&gt; の場合 -&gt;  &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20%5Csum_%7Bj%7D%7B%7D%20%28%20X_j%20%E3%81%8B%E3%82%89%E5%8F%B3%E3%81%ABD%E3%82%88%E3%82%8A%E9%9B%A2%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E9%83%BD%E5%B8%82%E6%95%B0%29%20&quot; alt=&quot; \sum_{j}{} ( X_j &amp;#x304B;&amp;#x3089;&amp;#x53F3;&amp;#x306B;D&amp;#x3088;&amp;#x308A;&amp;#x96E2;&amp;#x308C;&amp;#x3066;&amp;#x3044;&amp;#x308B;&amp;#x90FD;&amp;#x5E02;&amp;#x6570;) &quot;/&gt;&lt;br /&gt;
真ん中は左端からD以内だが、右端が真ん中から D以上離れている。&lt;br /&gt;
真ん中を決めうちし、右端の候補数を足し合わせたい。&lt;/p&gt;&lt;p&gt;3. &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20%28X_k%20-%20X_i%20%29%20%5Cleqq%20D%20&quot; alt=&quot; (X_k - X_i ) \leqq D &quot;/&gt; の場合 -&gt; &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20%7B%7D_%28X_i%E3%81%8B%E3%82%89%E5%8F%B3%E3%81%ABD%E4%BB%A5%E5%86%85%E3%81%AB%E3%81%82%E3%82%8B%E9%83%BD%E5%B8%82%E6%95%B0%29%20C%20_2&quot; alt=&quot; {}_(X_i&amp;#x304B;&amp;#x3089;&amp;#x53F3;&amp;#x306B;D&amp;#x4EE5;&amp;#x5185;&amp;#x306B;&amp;#x3042;&amp;#x308B;&amp;#x90FD;&amp;#x5E02;&amp;#x6570;) C _2&quot;/&gt; 通り&lt;br /&gt;
左端と右端がD以内の距離にある場合。この時、真ん中の点もD以内にある。&lt;br /&gt;
よって、(左端から右にD以内の都市) の中から2つ選ぶ組み合わせに対応する。&lt;/p&gt;&lt;p&gt;1,2,3で全ての場合を尽くしているので、これを全ての i に対して合計して、最後全体から引けば良い。&lt;/p&gt;&lt;p&gt;ここで、1,2で何度も &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20%28%20D%E3%82%88%E3%82%8A%E9%9B%A2%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E9%83%BD%E5%B8%82%E6%95%B0%20%29%20&quot; alt=&quot; ( D&amp;#x3088;&amp;#x308A;&amp;#x96E2;&amp;#x308C;&amp;#x3066;&amp;#x3044;&amp;#x308B;&amp;#x90FD;&amp;#x5E02;&amp;#x6570; ) &quot;/&gt;を使っており、2ではこれの累積値を取っていることから、&lt;br /&gt;
あらかじめ累積和を取っておくと2がスムーズに計算できそう。&lt;br /&gt;
各都市に対して、右にD以上離れている最小のindexの都市を二分探索で求める。&lt;br /&gt;
 -&gt; 累積和をとる。累積前も取っておくといいかな (?)&lt;/p&gt;&lt;p&gt;3の &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20%28D%E4%BB%A5%E5%86%85%E3%81%AE%E9%83%BD%E5%B8%82%E6%95%B0%29&quot; alt=&quot; (D&amp;#x4EE5;&amp;#x5185;&amp;#x306E;&amp;#x90FD;&amp;#x5E02;&amp;#x6570;)&quot;/&gt; は&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20%28D%E3%82%88%E3%82%8A%E9%9B%A2%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E9%83%BD%E5%B8%82%E6%95%B0%29%20&quot; alt=&quot; (D&amp;#x3088;&amp;#x308A;&amp;#x96E2;&amp;#x308C;&amp;#x3066;&amp;#x3044;&amp;#x308B;&amp;#x90FD;&amp;#x5E02;&amp;#x6570;) &quot;/&gt; から簡単に求まるので心配なし。&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9&quot;&gt;ソースコード&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://bitflyer2018-qual.contest.atcoder.jp/submissions/2603957&quot;&gt;Submission #2603957 - codeFlyer &amp;#xFF08;bitFlyer Programming Contest&amp;#xFF09; | AtCoder&lt;/a&gt;&lt;/p&gt;
</content>        
        <category term="競技プログラミング" label="競技プログラミング" />
        
        <link rel="enclosure" href="https://chart.apis.google.com/chart?cht=tx&amp;chl=%20O%28N%5E2%20%5Clog%20N%20%29" type="" length="0" />

        <author>
            <name>banboooo</name>
        </author>
    </entry>
    
  
    
    
    <entry>
        <title>自作ライブラリ(行列編)</title>
        <link href="http://banboooo.hatenablog.com/entry/2018/05/25/191100"/>
        <id>hatenablog://entry/17391345971647896498</id>
        <published>2018-05-25T19:11:00+09:00</published>
        <updated>2018-05-25T19:11:00+09:00</updated>        <summary type="html">気が向いたので作ってみました。固有値求める機能とかも追加したいけどとりあえず後回し。四則演算,累乗,ビット演算,転置,行列式,逆行列とかその辺は実装しました〜</summary>
        <content type="html">&lt;p&gt;気が向いたので作ってみました。&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%B8%C7%CD%AD%C3%CD&quot;&gt;固有値&lt;/a&gt;求める機能とかも追加したいけどとりあえず後回し。&lt;/p&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/banboooo044/868441312c9b34fa4fadd2bdd6d8f165.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;四則演算,累乗,ビット演算,転置,&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%B9%D4%CE%F3%BC%B0&quot;&gt;行列式&lt;/a&gt;,&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%B5%D5%B9%D4%CE%F3&quot;&gt;逆行列&lt;/a&gt;とかその辺は実装しました〜&lt;/p&gt;
</content>        
        <link rel="enclosure" href="https://cdn.blog.st-hatena.com/images/theme/og-image-1500.png" type="image/png" length="0" />

        <author>
            <name>banboooo</name>
        </author>
    </entry>
    
  
    
    
    <entry>
        <title>ABC034 ~食塩水~</title>
        <link href="http://banboooo.hatenablog.com/entry/2018/04/30/160955"/>
        <id>hatenablog://entry/17391345971639937926</id>
        <published>2018-04-30T16:09:55+09:00</published>
        <updated>2019-11-09T00:24:14+09:00</updated>        <summary type="html">D - 食塩水 解いたのでメモ。悩んだけど、どうやら典型の模様。 蟻本p132の「平均最大化」とほとんど同じ問題。 最初は、ナップザック問題っぽいなぁと思って、DPを必死に考えてたけど よくよく考えてみれば以下の式は別物。 本問 : ナップザック : ~ アルゴリズム ~ 目標の を決めてあげて、この濃度以上のものが作れるか判定する。 濃度 以上のものが作れる or 作れないの境界値が今回の答えの値。まず、判定をどうするか。目標を とすれば各容器 に対し、 を求めて、貪欲に大きいものからとって 0以上なら は作れる。0未満なら作れないとやれば良い。 判定ができれば、あとは境界値を探れば良い。ソ…</summary>
        <content type="html">&lt;p&gt;&lt;a href=&quot;https://beta.atcoder.jp/contests/abc034/tasks/abc034_d&quot;&gt;D - &amp;#x98DF;&amp;#x5869;&amp;#x6C34;&lt;/a&gt;&lt;br /&gt;
解いたのでメモ。悩んだけど、どうやら典型の模様。&lt;br /&gt;
蟻本p132の「平均最大化」とほとんど同じ問題。&lt;br /&gt;
最初は、ナップザック問題っぽいなぁと思って、DPを必死に考えてたけど&lt;br /&gt;
よくよく考えてみれば以下の式は別物。&lt;br /&gt;
本問 : &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20max%28%5Cdfrac%7B%5Csum%20v%7D%7B%5Csum%20w%7D%29&quot; alt=&quot; max(\dfrac{\sum v}{\sum w})&quot;/&gt; &lt;br /&gt;
ナップザック : &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20max%28%5Csum%20v%29%20%5C%20%5C%20%7B%5Csum%20w%20%5Cleq%20const%7D&quot; alt=&quot; max(\sum v) \ \ {\sum w \leq const}&quot;/&gt;&lt;/p&gt;&lt;p&gt;~ &lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0&quot;&gt;アルゴリズム&lt;/a&gt; ~&lt;br /&gt;
目標の &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20p&quot; alt=&quot; p&quot;/&gt; を決めてあげて、この濃度以上のものが作れるか判定する。&lt;br /&gt;
濃度 &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20p&quot; alt=&quot; p&quot;/&gt; 以上のものが作れる or 作れないの境界値が今回の答えの値。&lt;/p&gt;&lt;p&gt;まず、判定をどうするか。目標を &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20P%5E%2A&quot; alt=&quot; P^*&quot;/&gt; とすれば各容器 &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20i&quot; alt=&quot; i&quot;/&gt; に対し、&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20w_i%20%5Ctimes%20%28P%5E%2A%20-%20p_i%29&quot; alt=&quot; w_i \times (P^* - p_i)&quot;/&gt; を求めて、貪欲に大きいものからとって 0以上なら &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20P%5E%2A&quot; alt=&quot; P^*&quot;/&gt; は作れる。0未満なら作れないとやれば良い。&lt;br /&gt;
&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20%28%E5%AE%9F%E9%9A%9B%E3%81%AE%E9%A3%9F%E5%A1%A9%E3%81%AE%E9%87%8F%29%20%3D%20p_i%20w_i%20%2B%20p_%7Bi%2B1%7D%20w_%7Bi%2B1%7D%20%2B%20...%20&quot; alt=&quot; (&amp;#x5B9F;&amp;#x969B;&amp;#x306E;&amp;#x98DF;&amp;#x5869;&amp;#x306E;&amp;#x91CF;) = p_i w_i + p_{i+1} w_{i+1} + ... &quot;/&gt;&lt;br /&gt;
&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20%28%E5%BF%85%E8%A6%81%E3%81%AA%E9%A3%9F%E5%A1%A9%E3%81%AE%E9%87%8F%29%20%3D%20P%5E%2A%20%5Csum%20w%20%3D%20P%5E%2Aw_i%20%2B%20P%5E%2Aw_%7Bi%2B1%7D%20%2B...%20&quot; alt=&quot; (&amp;#x5FC5;&amp;#x8981;&amp;#x306A;&amp;#x98DF;&amp;#x5869;&amp;#x306E;&amp;#x91CF;) = P^* \sum w = P^*w_i + P^*w_{i+1} +... &quot;/&gt;&lt;/p&gt;&lt;p&gt;判定ができれば、あとは境界値を探れば良い。&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9&quot;&gt;ソースコード&lt;/a&gt; &lt;br /&gt;
&lt;a href=&quot;https://beta.atcoder.jp/contests/abc034/submissions/2374269&quot;&gt;Submission #2374269 - AtCoder Beginner Contest 034&lt;/a&gt;&lt;/p&gt;&lt;br /&gt;
&lt;p&gt;まとめ : &lt;br /&gt;
&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20max%28%5Cdfrac%7B%5Csum%20v%7D%7B%5Csum%20w%7D%29&quot; alt=&quot; max(\dfrac{\sum v}{\sum w})&quot;/&gt; を求めるのは典型 ! 二分探索 + 貪欲&lt;/p&gt;
</content>        
        <category term="競技プログラミング" label="競技プログラミング" />
        
        <link rel="enclosure" href="https://chart.apis.google.com/chart?cht=tx&amp;chl=%20max%28%5Cdfrac%7B%5Csum%20v%7D%7B%5Csum%20w%7D%29" type="" length="0" />

        <author>
            <name>banboooo</name>
        </author>
    </entry>
    
  
    
    
    <entry>
        <title>ARC094/ABC093  D:Worst Case</title>
        <link href="http://banboooo.hatenablog.com/entry/2018/04/08/191942"/>
        <id>hatenablog://entry/17391345971633376575</id>
        <published>2018-04-08T19:19:42+09:00</published>
        <updated>2019-11-09T00:23:46+09:00</updated>        <summary type="html">700点問題のD問題。むずかった。 D - Worst Case 高橋君のとった得点を とする。 高橋君よりスコアの小さい最大の人数を求めたいので、1つ目のコンテストが高いスコアならば、2回目は低いスコア(逆もしかり)というように掛け算のペアを作ってあげる。(考察1) (わからなければ解説放送へ) www.youtube.com 高橋君よりスコアが小さい人のスコア は必ず または を満たすので まず、 の場合を考えてみる。 (考察1)より、以下のようにペアを考えることができる。 すると、この場合はすべてのペアの積がABより小さくなることがわかる。 次に の場合を考えてみる。先ほどのように を元…</summary>
        <content type="html">&lt;p&gt;700点問題のD問題。むずかった。&lt;br /&gt;
&lt;a href=&quot;https://beta.atcoder.jp/contests/arc094/tasks/arc094_b&quot;&gt;D - Worst Case&lt;/a&gt;&lt;br /&gt;
高橋君のとった得点を &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=A%2CB%20%28%20A%20%5Cleq%20B%29&quot; alt=&quot;A,B ( A \leq B)&quot;/&gt; とする。&lt;br /&gt;
高橋君よりスコアの小さい最大の人数を求めたいので、1つ目のコンテストが高いスコアならば、2回目は低いスコア(逆もしかり)というように掛け算のペアを作ってあげる。(考察1)&lt;br /&gt;
(わからなければ解説放送へ)&lt;br /&gt;
&lt;iframe src=&quot;https://hatenablog-parts.com/embed?url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DHDRfgn_UXLE&quot; title=&quot;YouTube&quot; class=&quot;embed-card embed-webcard&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;&quot;&gt;&lt;/iframe&gt;&lt;cite class=&quot;hatena-citation&quot;&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=HDRfgn_UXLE&quot;&gt;www.youtube.com&lt;/a&gt;&lt;/cite&gt;&lt;br /&gt;
高橋君よりスコアが小さい人のスコア &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=a%2Cb%20%28%20a%20%5Cleq%20b%29&quot; alt=&quot;a,b ( a \leq b)&quot;/&gt; は必ず  &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=a%20%3C%20A&quot; alt=&quot;a &amp;lt; A&quot;/&gt; または &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20b%20%3C%20B&quot; alt=&quot; b &amp;lt; B&quot;/&gt; を満たすので&lt;br /&gt;
まず、 &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=a%20%3C%20A&quot; alt=&quot;a &amp;lt; A&quot;/&gt;  の場合を考えてみる。&lt;br /&gt;
(考察1)より、以下のようにペアを考えることができる。&lt;br /&gt;
&lt;span itemscope itemtype=&quot;http://schema.org/Photograph&quot;&gt;&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/b/banboooo/20180408/20180408143002.jpg&quot; alt=&quot;f:id:banboooo:20180408143002j:plain&quot; title=&quot;f:id:banboooo:20180408143002j:plain&quot; class=&quot;hatena-fotolife&quot; itemprop=&quot;image&quot;&gt;&lt;/span&gt;&lt;br /&gt;
すると、この場合はすべてのペアの積がABより小さくなることがわかる。&lt;br /&gt;
次に &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=b%20%3C%20B&quot; alt=&quot;b &amp;lt; B&quot;/&gt; の場合を考えてみる。先ほどのように &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=1%20%5Csim%20%28B-1%29&quot; alt=&quot;1 \sim (B-1)&quot;/&gt; を元に、対応する &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=A&quot; alt=&quot;A&quot;/&gt; より大きい数を考えても、必ずABより大きいことが保証される数列が見つからない。&lt;br /&gt;
ここで発想を転換して、&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%28A%2B1%29%20%5Csim%20&quot; alt=&quot;(A+1) \sim &quot;/&gt; を元に、対応する数を考える。すると、積の最大値がABを超えない範囲で数列の長さを最大にする問題と捉えることができる。&lt;br /&gt;
ここまでを整理すると以下の図になる。&lt;br /&gt;
&lt;span itemscope itemtype=&quot;http://schema.org/Photograph&quot;&gt;&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/b/banboooo/20180408/20180408152026.jpg&quot; alt=&quot;f:id:banboooo:20180408152026j:plain&quot; title=&quot;f:id:banboooo:20180408152026j:plain&quot; class=&quot;hatena-fotolife&quot; itemprop=&quot;image&quot;&gt;&lt;/span&gt;&lt;br /&gt;
ここからは2つほど解法があると思ったのだが、2つ目の方は実装で挫折してしまった。1つ目は、editorialの方法。2つ目は2分探索と3分探索を組み合わせる方法。&lt;br /&gt;
考え方などで間違っていたら教えていただきたいです。&lt;/p&gt;&lt;p&gt;1.editorialの方法&lt;br /&gt;
&lt;a href=&quot;https://beta.atcoder.jp/contests/arc094/submissions/2325009&quot;&gt;https://beta.atcoder.jp/contests/arc094/submissions/2325009&lt;/a&gt;&lt;br /&gt;
&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20C%5E2%20%3C%20AB&quot; alt=&quot; C^2 &amp;lt; AB&quot;/&gt; を満たす &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=C&quot; alt=&quot;C&quot;/&gt; を取ると、&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20C%28C%2B1%29&quot; alt=&quot; C(C+1)&quot;/&gt; または &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20C%5E2&quot; alt=&quot; C^2&quot;/&gt; が積の最大値となることを利用する方法。&lt;br /&gt;
これは掛け算のペアの和が常に一定ならば&lt;br /&gt;
ペアの数が同じくらいの大きさの時に、積の値が最大となるからである。&lt;br /&gt;
さらに例外的に、&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20A%20%3D%20B&quot; alt=&quot; A = B&quot;/&gt; の時と &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20A%2B1%20%3D%20B&quot; alt=&quot; A+1 = B&quot;/&gt; の時は、&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20C%20%3D%20A&quot; alt=&quot; C = A&quot;/&gt; となってしまうので、別で処理しないといけない。&lt;br /&gt;
これを踏まえると以下のように考えることができる。&lt;br /&gt;
&lt;span itemscope itemtype=&quot;http://schema.org/Photograph&quot;&gt;&lt;a href=&quot;http://f.hatena.ne.jp/banboooo/20180408154145&quot; class=&quot;hatena-fotolife&quot; itemprop=&quot;url&quot;&gt;&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/b/banboooo/20180408/20180408154145.jpg&quot; alt=&quot;f:id:banboooo:20180408154145j:image:w600&quot; title=&quot;f:id:banboooo:20180408154145j:image:w600&quot; class=&quot;hatena-fotolife&quot; style=&quot;width:600px&quot; itemprop=&quot;image&quot;&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;br /&gt;
&lt;p&gt;2.三分探索 &amp; 二分探索の方法 (仮)&lt;br /&gt;
&lt;a href=&quot;https://beta.atcoder.jp/contests/arc094/submissions/2325717&quot;&gt;https://beta.atcoder.jp/contests/arc094/submissions/2325717&lt;/a&gt; &lt;- 不正解になってしまった提出。&lt;br /&gt;
&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20C&quot; alt=&quot; C&quot;/&gt; の値をとることに気づかない場合は、こっち。&lt;br /&gt;
積の最大値を求めたいため、探索をするが逐次探索では当然間に合わない。&lt;br /&gt;
そこで、積の値の関数の形に注目してみると上凸の関数になっているはずである。&lt;br /&gt;
&lt;span itemscope itemtype=&quot;http://schema.org/Photograph&quot;&gt;&lt;a href=&quot;http://f.hatena.ne.jp/banboooo/20180408160502&quot; class=&quot;hatena-fotolife&quot; itemprop=&quot;url&quot;&gt;&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/b/banboooo/20180408/20180408160502.jpg&quot; alt=&quot;f:id:banboooo:20180408160502j:image:w300&quot; title=&quot;f:id:banboooo:20180408160502j:image:w300&quot; class=&quot;hatena-fotolife&quot; style=&quot;width:300px&quot; itemprop=&quot;image&quot;&gt;&lt;/a&gt;&lt;/span&gt;&lt;br /&gt;
こういう時は、三分探索を使えば、&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%B6%CB%C3%CD&quot;&gt;極値&lt;/a&gt;、今回で言えば積の最大値を非常に効率よく求められる。&lt;br /&gt;
&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%B6%CB%C3%CD&quot;&gt;極値&lt;/a&gt;を&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20X&quot; alt=&quot; X&quot;/&gt;の関数と見れば、この関数は単調非減少の関数なので、こちらは二分探索で&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=X&quot; alt=&quot;X&quot;/&gt;を定めてあげれば答えがもとまる。&lt;/p&gt;
</content>        
        <category term="競技プログラミング" label="競技プログラミング" />
        
        <link rel="enclosure" href="https://chart.apis.google.com/chart?cht=tx&amp;chl=A%2CB%20%28%20A%20%5Cleq%20B%29" type="" length="0" />

        <author>
            <name>banboooo</name>
        </author>
    </entry>
    
  
    
    
    <entry>
        <title>自作ライブラリ(整数編)</title>
        <link href="http://banboooo.hatenablog.com/entry/2018/04/01/163800"/>
        <id>hatenablog://entry/17391345971631352881</id>
        <published>2018-04-01T16:38:00+09:00</published>
        <updated>2019-11-09T00:16:42+09:00</updated>        <summary type="html">競プロ用の整数周りのライブラリ(言語はc++14用) 使用可能なメソッド 1.素数関連 エラトステネスのふるい 素数かどうか判定 素数列挙 n以下の素数の個数 2.約数倍数関連 素因数分解 3.階乗累乗関連 ※数が大きいのでを法としてmodをとっている。 n階乗 mod割り算 template &lt;typename T&gt; class Integer { private: const long mod = 1000000007; bool primeflg; bool factorialflg; vector&lt;T&gt; prime_list; vector&lt;T&gt; factorial; map&lt;T,lo…</summary>
        <content type="html">&lt;p&gt;競プロ用の整数周りのライブラリ(言語は&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/c%2B%2B&quot;&gt;c++&lt;/a&gt;14用)&lt;br /&gt;
使用可能なメソッド&lt;br /&gt;
1.&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%C1%C7%BF%F4&quot;&gt;素数&lt;/a&gt;関連&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;エラトステネスのふるい&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%C1%C7%BF%F4&quot;&gt;素数&lt;/a&gt;かどうか判定&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%C1%C7%BF%F4&quot;&gt;素数&lt;/a&gt;列挙&lt;/li&gt;
&lt;li&gt;n以下の&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%C1%C7%BF%F4&quot;&gt;素数&lt;/a&gt;の個数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2.約数倍数関連&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%C1%C7%B0%F8%BF%F4%CA%AC%B2%F2&quot;&gt;素因数分解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=gcd%2Clcm&quot; alt=&quot;gcd,lcm&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3.階乗累乗関連&lt;br /&gt;
※数が大きいので&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=10%5E9%20%2B%207&quot; alt=&quot;10^9 + 7&quot;/&gt;を法としてmodをとっている。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;n階乗&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=a%5Ex&quot; alt=&quot;a^x&quot;/&gt;&lt;/li&gt;
&lt;li&gt;mod割り算&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=nCr%2CnPr&quot; alt=&quot;nCr,nPr&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;code&quot; data-lang=&quot;&quot; data-unlink&gt;template &amp;lt;typename T&amp;gt;
class Integer {
private:
	const long mod = 1000000007;
	bool primeflg;
	bool factorialflg;
	vector&amp;lt;T&amp;gt; prime_list;
	vector&amp;lt;T&amp;gt; factorial;
	map&amp;lt;T,long&amp;gt; factoring;
	vector&amp;lt;long&amp;gt; prime_num;
	vector&amp;lt;bool&amp;gt; prime_table;

	void factorialModInit(T maxval) {
		factorialflg = true;
		factorial = vector&amp;lt;T&amp;gt;(maxval+1); 
		factorial[0] = factorial[1] = 1;
		for (T i = 2;i &amp;lt; (maxval+1);i++) {
			factorial[i] = (factorial[i-1]*i)%mod;
		}
	}

public:
	Integer()  : primeflg(false),factorialflg(false) {}

	//素数関連
	void Eratosthenes(T n) { // n以下の数でエラトステネスのふるいを作る。 
		primeflg = true;
		prime_table = vector&amp;lt;bool&amp;gt;(n+1,true);
		prime_num = vector&amp;lt;long&amp;gt;(n+1,0);
		T maxiter = sqrt(n);
		for(T i = 2;i &amp;lt; maxiter+1;i++){
			if (prime_table[i]) {
				for (T j = (i + i);j &amp;lt;= n;j += i){
					prime_table[j] = false;
				}
			}
		}
		T prnum = 0;
		for(T i = 2;i &amp;lt; n+1;i++){
			if (prime_table[i]) {
				prnum++;
				prime_list.push_back(i);
			}
			prime_num[i] = prnum;
		}
	}

	bool isPrimeNum(T n) { //素数かどうか判定
		if (!primeflg) Eratosthenes(max(n,(T)100)); 
		return prime_table[n];
	}

	vector&amp;lt;T&amp;gt;* getPrimeList(T n = 100){ //n以下の素数リスト
		if (!primeflg) Eratosthenes(n); 
		return (&amp;amp;prime_list);
	}

	long getPrimeNumUnder_N(T n) { //n以下の素数の個数。
		if (!primeflg) Eratosthenes(max(n,(T)100)); 
		return prime_num[n];
	}

	long getPrimeNum_NM(T k,T m){  //k以上m以下の素数の個数。(kはN以下ならok)
		if (!primeflg) Eratosthenes(max(m,(T)100)); 
		return prime_num[m] - prime_num[k];
	}

	//約数倍数関連
	map&amp;lt;T,long&amp;gt;* getFactoring(T n) { // 素因数分解 key-&amp;gt;因数 val-&amp;gt;因数の数
		T copy_n = n;
		T maxiter = sqrt(n);
		for (T i = 2;i &amp;lt; maxiter+1;i ++) {
			if (copy_n == 1) break;
			while (!(copy_n % i)) {
				if (IN(i,factoring)) factoring[i]++;
				else factoring[i] = 1;
				copy_n /= i;
			}
		}
		return (&amp;amp;factoring);
	}

	T gcd(T a,T b) {
 		 return b != 0 ? gcd(b, a % b) : a;
	}

	T lcm(T a,T b) {
  		return (a / gcd(a, b))*b;
	}

	long getFactorial(T n) { // nの階乗の値を求める。
		if (!factorialflg) factorialModInit(n);
		return factorial[n];
	}

	long long square_pow(long long a,long x){ // (a^x) % mod (繰り返し二乗)
		T p = a;
		T q = 1LL;
		while (x != 0){
			if (x &amp;amp; 1) q = (q * p) % mod;
			p = (p * p) % mod;
			x &amp;gt;&amp;gt;= 1;
		}	
		return q;
	}

	long long mod_inv(long long a) { // aの逆元 % mod
		return square_pow(a,mod-2);
	}

       long long nCr(T n,T r) { //普通のnCr,modを取らない場合はこっち
		if (r &amp;gt; n / 2)  r = n - r;
		long long retval = 1;
		for (long i = 1;i &amp;lt; r+1;i ++){
			retval *= n - r + i;
			retval /= i;
		}
		return retval;
	}

	long long nCrMod(T n,T r) { // nCr 使用前に初期化必要
		if (!factorialflg) factorialModInit(n);
		return (((factorial[n]%mod * mod_inv(factorial[r]))%mod) * mod_inv(factorial[n-r]))%mod;
	}

	long long nPrMod(T n,T r) {
		if (!factorialflg) factorialModInit(n);
		return ((factorial[n]%mod) * mod_inv(factorial[n-r]))%mod;
	}
};&lt;/pre&gt;&lt;p&gt;使用例&lt;/p&gt;
&lt;pre class=&quot;code&quot; data-lang=&quot;&quot; data-unlink&gt;int main(void){
	Integer&amp;lt;long&amp;gt; it; //インスタンス生成

	it.Eratosthenes(100L);
	cout &amp;lt;&amp;lt; it.isPrimeNum(53) &amp;lt;&amp;lt; endl;                  // -&amp;gt; 1 (true)
	cout &amp;lt;&amp;lt; it.getPrimeNumUnder_N(50) &amp;lt;&amp;lt; endl; // -&amp;gt; 15

	map&amp;lt;long,long&amp;gt;* m = it.getFactoring(12);
	for(auto itr = m-&amp;gt;begin(); itr != m-&amp;gt;end(); ++itr) { 
		cout &amp;lt;&amp;lt; itr-&amp;gt;first &amp;lt;&amp;lt; &amp;#34; ^ &amp;#34;  &amp;lt;&amp;lt; itr-&amp;gt;second &amp;lt;&amp;lt; endl; 
	} // -&amp;gt; 2 ^ 2 , 3 ^ 1

	cout &amp;lt;&amp;lt; it.gcd(18,12) &amp;lt;&amp;lt; endl; // -&amp;gt; 6
	cout &amp;lt;&amp;lt; it.lcm(18,12) &amp;lt;&amp;lt; endl; // -&amp;gt; 36

	cout &amp;lt;&amp;lt; it.getFactorial(8) &amp;lt;&amp;lt; endl; // -&amp;gt; 40320 (= 8!)
	cout &amp;lt;&amp;lt; it.square_pow(2LL,10) &amp;lt;&amp;lt; endl; // -&amp;gt; 1024
	cout &amp;lt;&amp;lt; it.nCrMod(8,3) &amp;lt;&amp;lt; endl; // -&amp;gt; 56
	return 0;
}&lt;/pre&gt;</content>        
        <category term="競技プログラミング" label="競技プログラミング" />
        
        <link rel="enclosure" href="https://chart.apis.google.com/chart?cht=tx&amp;chl=gcd%2Clcm" type="" length="0" />

        <author>
            <name>banboooo</name>
        </author>
    </entry>
    
  
    
    
    <entry>
        <title>Educational Codeforces Round 38 D問題</title>
        <link href="http://banboooo.hatenablog.com/entry/2018/03/11/014426"/>
        <id>hatenablog://entry/17391345971624242225</id>
        <published>2018-03-11T01:44:26+09:00</published>
        <updated>2019-11-09T00:23:11+09:00</updated>        <summary type="html">競プロ界ではとても有名(?)なダイクストラ法。 典型問題からちょっとひねった問題で個人的には良問だと思った。 codeforces.com 問題文の要約 (訳に脚色入ってます。) 個の町と本の道があって道には通行料が存在。コンサートが全ての町で行われるが、チケット料も町ごとに異なる。町にいる人が、コンサートを一番安く見る時、その料金(他の町へ行くなら通行料往復分込み)を表示せよ。 アルゴリズム まずグラフ構造に直す。頂点辺、辺の重みは往復分の通行料とできる。 さて、チケット料の情報をどう扱うかが今回最大の工夫ポイント。 まず、一つの頂点 について考える。通常のダイクストラでは最初優先度付きキュ…</summary>
        <content type="html">&lt;p&gt;競プロ界ではとても有名(?)な&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%A5%C0%A5%A4%A5%AF%A5%B9%A5%C8%A5%E9&quot;&gt;ダイクストラ&lt;/a&gt;法。&lt;br /&gt;
典型問題からちょっとひねった問題で個人的には良問だと思った。&lt;br /&gt;
&lt;iframe src=&quot;https://hatenablog-parts.com/embed?url=http%3A%2F%2Fcodeforces.com%2Fcontest%2F938%2Fproblem%2FD&quot; title=&quot;Problem - D - Codeforces&quot; class=&quot;embed-card embed-webcard&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;&quot;&gt;&lt;/iframe&gt;&lt;cite class=&quot;hatena-citation&quot;&gt;&lt;a href=&quot;http://codeforces.com/contest/938/problem/D&quot;&gt;codeforces.com&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;

&lt;div class=&quot;section&quot;&gt;
    &lt;h4&gt;問題文の要約 (訳に脚色入ってます。)&lt;/h4&gt;
    &lt;p&gt;&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=n&quot; alt=&quot;n&quot;/&gt;個の町と&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=m&quot; alt=&quot;m&quot;/&gt;本の道があって道には通行料が存在。コンサートが全ての町で行われるが、チケット料も町ごとに異なる。町&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=i&quot; alt=&quot;i&quot;/&gt;にいる人が、コンサートを一番安く見る時、その料金(他の町へ行くなら通行料往復分込み)を表示せよ。&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;section&quot;&gt;
    &lt;h4&gt;&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0&quot;&gt;アルゴリズム&lt;/a&gt;&lt;/h4&gt;
    &lt;p&gt;まずグラフ構造に直す。&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=n&quot; alt=&quot;n&quot;/&gt;頂点&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=m&quot; alt=&quot;m&quot;/&gt;辺、辺の重みは往復分の通行料&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=w_%7Bij%7D%20%5Ctimes%202&quot; alt=&quot;w_{ij} \times 2&quot;/&gt;とできる。&lt;br /&gt;
さて、チケット料の情報をどう扱うかが今回最大の工夫ポイント。&lt;br /&gt;
まず、一つの頂点 &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=v_s&quot; alt=&quot;v_s&quot;/&gt; について考える。通常の&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%A5%C0%A5%A4%A5%AF%A5%B9%A5%C8%A5%E9&quot;&gt;ダイクストラ&lt;/a&gt;では最初優先度付きキューに&lt;br /&gt;
(0,始点)をpushするが、今回は(チケット料 &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20a&quot; alt=&quot; a&quot;/&gt; , &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=v_s&quot; alt=&quot;v_s&quot;/&gt;)をpushする。&lt;br /&gt;
ここで下図のような例を考えて、頂点&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=v_s&quot; alt=&quot;v_s&quot;/&gt; からの最短距離の意味を考える。&lt;br /&gt;
&lt;span itemscope itemtype=&quot;http://schema.org/Photograph&quot;&gt;&lt;a href=&quot;http://f.hatena.ne.jp/banboooo/20180311010500&quot; class=&quot;hatena-fotolife&quot; itemprop=&quot;url&quot;&gt;&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/b/banboooo/20180311/20180311010500.jpg&quot; alt=&quot;f:id:banboooo:20180311010500j:image:w400&quot; title=&quot;f:id:banboooo:20180311010500j:image:w400&quot; class=&quot;hatena-fotolife&quot; style=&quot;width:400px&quot; itemprop=&quot;image&quot;&gt;&lt;/a&gt;&lt;/span&gt;&lt;br /&gt;
このように、頂点&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=v_s&quot; alt=&quot;v_s&quot;/&gt;から頂点&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=v_t&quot; alt=&quot;v_t&quot;/&gt;までの最短距離が、&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=v_t&quot; alt=&quot;v_t&quot;/&gt;から&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=v_s&quot; alt=&quot;v_s&quot;/&gt;へコンサートを見に行った時の最小の料金となっている。後は同様に全ての頂点に対して行えば良いのだが、最小の料金 = 最短距離 に対応しているので最初に(チケット料,&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=v&quot; alt=&quot;v&quot;/&gt;)を全ての頂点分pushして&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%A5%C0%A5%A4%A5%AF%A5%B9%A5%C8%A5%E9&quot;&gt;ダイクストラ&lt;/a&gt;法をやれば &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=distance&quot; alt=&quot;distance&quot;/&gt;配列 (通常は始点からの距離を格納する配列)に本問題の答えが格納されている。&lt;br /&gt;
計算量は、最初にpushする分だけ増えて &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20O%20%28%20V%20%2B%20%7CE%7C%20%5Clog%20%7CV%7C%29%20%5Capprox%2010%5E6&quot; alt=&quot; O ( V + |E| \log |V|) \approx 10^6&quot;/&gt;&lt;br /&gt;
 (間違ってたらごめんなさい)&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;section&quot;&gt;
    &lt;h4&gt;&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9&quot;&gt;ソースコード&lt;/a&gt;&lt;/h4&gt;
    &lt;pre class=&quot;code c++&quot; data-lang=&quot;c++&quot; data-unlink&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
#define REP(i,n) for (long i=0;i&amp;lt;(n);i++)
#define FOR(i,a,b) for (long i=(a);i&amp;lt;(b);i++)
#define RREP(i,n) for(long i=n;i&amp;gt;=0;i--)
#define RFOR(i,a,b) for(long i=(a);i&amp;gt;(b);i--)
#define dump1d_arr(array) REP(i,array.size()) cerr &amp;lt;&amp;lt; #array &amp;lt;&amp;lt; &amp;#34;[&amp;#34; &amp;lt;&amp;lt; (i) &amp;lt;&amp;lt; &amp;#34;] ==&amp;gt; &amp;#34; &amp;lt;&amp;lt; (array[i]) &amp;lt;&amp;lt; endl;
#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr &amp;lt;&amp;lt; #array &amp;lt;&amp;lt; &amp;#34;[&amp;#34; &amp;lt;&amp;lt; (i) &amp;lt;&amp;lt; &amp;#34;]&amp;#34; &amp;lt;&amp;lt; &amp;#34;[&amp;#34; &amp;lt;&amp;lt; (j) &amp;lt;&amp;lt; &amp;#34;] ==&amp;gt; &amp;#34; &amp;lt;&amp;lt; (array[i][j]) &amp;lt;&amp;lt; endl;
#define dump(x)  cerr &amp;lt;&amp;lt; #x &amp;lt;&amp;lt; &amp;#34; =&amp;gt; &amp;#34; &amp;lt;&amp;lt; (x) &amp;lt;&amp;lt; endl;
#define CLR(vec) { REP(i,vec.size()) vec[i] = 0; } 
#define llINF (long long) 9223372036854775807
#define loINF (long) 2147483647
#define shINF (short) 32767
#define SORT(c) sort((c).begin(),(c).end())
#define MIN(vec) *min_element(vec.begin(), vec.end());
#define MAX(vec) *max_element(vec.begin(), vec.end());
using namespace std;
typedef long long LL;
typedef vector&amp;lt;LL&amp;gt; VL;
typedef vector&amp;lt;VI&amp;gt; VVL;
typedef pair&amp;lt;LL,LL&amp;gt; pr;
struct ver {LL di,node,prev;};
struct Order {
	bool operator() (ver const&amp;amp; a,ver const&amp;amp; b) const {
		return a.di &amp;gt; b.di || ((a.di == b.di) &amp;amp;&amp;amp; (a.node &amp;gt; b.node));
	}
};
typedef priority_queue&amp;lt;ver,vector&amp;lt;ver&amp;gt;,Order&amp;gt; pq;

// ダイクストラ法
class Dijekstra {
private:
	vector&amp;lt;vector&amp;lt;pr&amp;gt;&amp;gt; E;
	vector&amp;lt;LL&amp;gt; dist;
	size_t V;
public:
	Dijekstra() : V(0) { }
	Dijekstra(size_t v) :
		V(v),E(v,vector&amp;lt;pr&amp;gt;(0)),dist(v,llINF) {}

	size_t size() { return V;}

	void add_edge_directed(LL from,LL to,LL dis){
		E[from].push_back(pr(to,dis));
	}

	void add_edge_undirected(LL from,LL to,LL dis){
		E[from].push_back(pr(to,dis));
		E[to].push_back(pr(from,dis));
	}	

	void dijekstra(VI weight){
		pq que;
		REP(i,weight.size()) que.push(ver{weight[i],i,i});

		while(! que.empty()){
			ver next = que.top();
			que.pop();
			LL next_v = next.node;
			if (dist[next_v] &amp;lt; next.di) continue; //決定済み
			dist[next_v] = next.di;
			
			REP(i,E[next_v].size()){
				pr e = E[next_v][i];
				if (dist[e.first] &amp;gt; next.di+e.second) {
                                       que.push(ver{next.di+e.second,e.first,next_v});
                                 }
			}
		}
	}

	vector&amp;lt;LL&amp;gt; result(void){
		return dist;
	}

	long result_query(long goal){
		return dist[goal];
	}
};


int main(void){
	long n,m,v,u;
	LL w;
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;

	Dijekstra dj(n);

	REP(i,m){
		cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v &amp;gt;&amp;gt; w;
		dj.add_edge_undirected(u-1,v-1,w*2); //添え字に注意
	}

	VI weight(n);
	REP(i,n) cin &amp;gt;&amp;gt; weight[i];

	dj.dijekstra(weight);
	VI ans = dj.result();
	REP(i,n) cout &amp;lt;&amp;lt; ans[i] &amp;lt;&amp;lt; &amp;#34; &amp;#34;;
	cout &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;

	return 0;
}&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot;&gt;
    &lt;h4&gt;注意&lt;/h4&gt;
    &lt;p&gt;数は結構大きくなるのでlong long型じゃないと通らなかった。&lt;/p&gt;

&lt;/div&gt;</content>        
        <category term="競技プログラミング" label="競技プログラミング" />
        
        <link rel="enclosure" href="https://chart.apis.google.com/chart?cht=tx&amp;chl=n" type="" length="0" />

        <author>
            <name>banboooo</name>
        </author>
    </entry>
    
  
    
    
    <entry>
        <title>AGC021 ~B問題 Holes ~</title>
        <link href="http://banboooo.hatenablog.com/entry/2018/02/26/132858"/>
        <id>hatenablog://entry/17391345971619835129</id>
        <published>2018-02-26T13:28:58+09:00</published>
        <updated>2019-11-09T00:22:56+09:00</updated>        <summary type="html">初投稿です。個人的にはアルゴリズムも実装も大変だったので書き残しておきます。 agc021.contest.atcoder.jp乱数で決まるは半径の円の内部。穴は1辺 の正方形の内部の領域に存在する。 がめちゃめちゃ大きいので、穴の近くには滅多に落ちない。全体図穴を頂点とする凸多角形で、かつ全ての穴を内部含むような図形(凸包というらしい)を作る。乱数で決まる点は主に、この凸多角形の外側の領域に落ちるので、凸多角形の頂点になってる穴のどれかに落ちる。内部に落ちた時のみ、頂点に使われてない穴にも落ちる可能性があるが、確率は0とみなせる。(精度的に)つまり、凸多角形の頂点に対してのみ確率を考えればよ…</summary>
        <content type="html">&lt;p&gt;初投稿です。個人的には&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0&quot;&gt;アルゴリズム&lt;/a&gt;も実装も大変だったので書き残しておきます。&lt;br /&gt;
&lt;iframe src=&quot;https://hatenablog-parts.com/embed?url=https%3A%2F%2Fagc021.contest.atcoder.jp%2Ftasks%2Fagc021_b&quot; title=&quot;B: Holes - AtCoder Grand Contest 021 | AtCoder&quot; class=&quot;embed-card embed-webcard&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;&quot;&gt;&lt;/iframe&gt;&lt;cite class=&quot;hatena-citation&quot;&gt;&lt;a href=&quot;https://agc021.contest.atcoder.jp/tasks/agc021_b&quot;&gt;agc021.contest.atcoder.jp&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;&lt;p&gt;乱数で決まる&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%28x%2Cy%29&quot; alt=&quot;(x,y)&quot;/&gt;は半径&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=R&quot; alt=&quot;R&quot;/&gt;の円の内部。穴は1辺 &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=2%20%5Ctimes%2010%5E6%20&quot; alt=&quot;2 \times 10^6 &quot;/&gt;の正方形の内部の領域に存在する。&lt;br /&gt;
&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=R&quot; alt=&quot;R&quot;/&gt;がめちゃめちゃ大きいので、穴の近くには滅多に落ちない。&lt;/p&gt;&lt;p&gt;&lt;figure class=&quot;figure-image figure-image-fotolife&quot; title=&quot;全体&quot;&gt;&lt;span itemscope itemtype=&quot;http://schema.org/Photograph&quot;&gt;&lt;a href=&quot;http://f.hatena.ne.jp/banboooo/20180226021502&quot; class=&quot;hatena-fotolife&quot; itemprop=&quot;url&quot;&gt;&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/b/banboooo/20180226/20180226021502.jpg&quot; alt=&quot;f:id:banboooo:20180226021502j:image:w400&quot; title=&quot;f:id:banboooo:20180226021502j:image:w400&quot; class=&quot;hatena-fotolife&quot; style=&quot;width:400px&quot; itemprop=&quot;image&quot;&gt;&lt;/a&gt;&lt;/span&gt;&lt;figcaption&gt;全体図&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;&lt;p&gt;穴を頂点とする凸多角形で、かつ全ての穴を内部含むような図形(凸包というらしい)を作る。乱数で決まる点は主に、この凸多角形の外側の領域に落ちるので、凸多角形の頂点になってる穴のどれかに落ちる。&lt;/p&gt;&lt;p&gt;内部に落ちた時のみ、頂点に使われてない穴にも落ちる可能性があるが、確率は0とみなせる。(精度的に)つまり、凸多角形の頂点に対してのみ確率を考えればよい !!&lt;/p&gt;&lt;p&gt;隣同士の2つの穴について考えると、2つの穴を結んだ直線の垂直二等分線を基準に、どちらの穴に落ちるかがわかるので、これを凸多角形の全ての辺に対してやってみる。&lt;/p&gt;&lt;p&gt;すると、全部の垂直二等分線が中心に集まり、1点で交わるわけではないので小さい領域ができてしまうが、これらを無視すれば、下の図のように領域分割すれば良さそう。&lt;/p&gt;&lt;p&gt;&lt;figure class=&quot;figure-image figure-image-fotolife&quot; title=&quot;領域分割&quot;&gt;&lt;span itemscope itemtype=&quot;http://schema.org/Photograph&quot;&gt;&lt;a href=&quot;http://f.hatena.ne.jp/banboooo/20180226020127&quot; class=&quot;hatena-fotolife&quot; itemprop=&quot;url&quot;&gt;&lt;img src=&quot;https://cdn-ak.f.st-hatena.com/images/fotolife/b/banboooo/20180226/20180226020127.jpg&quot; alt=&quot;f:id:banboooo:20180226020127j:image:w400&quot; title=&quot;f:id:banboooo:20180226020127j:image:w400&quot; class=&quot;hatena-fotolife&quot; style=&quot;width:400px&quot; itemprop=&quot;image&quot;&gt;&lt;/a&gt;&lt;/span&gt;&lt;figcaption&gt;領域分割&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;&lt;p&gt;中心角 = (垂直二等分線の交わる角度) = &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cpi&quot; alt=&quot;\pi&quot;/&gt;- (辺の交わる角度)&lt;br /&gt;
例: 赤い領域の中心角 = &lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%20%5Cpi%20-%20%5Cangle%20BAE&quot; alt=&quot; \pi - \angle BAE&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0&quot;&gt;アルゴリズム&lt;/a&gt;はここまでだが、実装でも苦労した点が2点ほど。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;そもそも凸包はどうやって求めるのか。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;凸包を求める&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%A5%A2%A5%EB%A5%B4%A5%EA%A5%BA%A5%E0&quot;&gt;アルゴリズム&lt;/a&gt;で「グラハムスキャン」というのがあるらしい (蟻本p224)&lt;br /&gt;
2辺のベクトル(&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%5Cvec%7Bv1%7D%2C%5Cvec%7Bv2%7D&quot; alt=&quot;\vec{v1},\vec{v2}&quot;/&gt;)の符号付き角度が、&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=det%28v1%2Cv2%29&quot; alt=&quot;det(v1,v2)&quot;/&gt;の正負に一致するので、これが常に正になるように点を反時計回りに選ぶことがポイント。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;長さの値をどうやって角度の値に直すか。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最初は&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%5Carctan&quot; alt=&quot;\arctan&quot;/&gt;を使って角度に変換することを考えたが、場合分けが必要でめんどくさい。&lt;br /&gt;
そこでベクトルをおいて、&lt;img src=&quot;https://chart.apis.google.com/chart?cht=tx&amp;chl=%5Ctheta%20%3D%20%5Carccos%7B%5Cdfrac%7B%5Cvec%7Ba%7D%20%5Cvec%7Bb%7D%7D%7B%7Ca%7C%7Cb%7C%7D%7D&quot; alt=&quot;\theta = \arccos{\dfrac{\vec{a} \vec{b}}{|a||b|}}&quot;/&gt;で求めると楽だった。&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9&quot;&gt;ソースコード&lt;/a&gt;&lt;br /&gt;
まず二次元ベクトルの&lt;a class=&quot;keyword&quot; href=&quot;http://d.hatena.ne.jp/keyword/%C6%E2%C0%D1&quot;&gt;内積&lt;/a&gt;やノルムなどを簡単に求められるようにクラスを構築しておく。&lt;br /&gt;
なお、今回の問題では点ごとに確率を出力しないといけないので、indexの値を保持できるようにしておき、辺のベクトルを表すときは、indexの値は(-1)にしておいた。&lt;/p&gt;
&lt;pre class=&quot;code lang-cpp&quot; data-lang=&quot;cpp&quot; data-unlink&gt;&lt;span class=&quot;synType&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;struct&lt;/span&gt; vec2D {
  &lt;span class=&quot;synType&quot;&gt;double&lt;/span&gt; x, y;
  &lt;span class=&quot;synType&quot;&gt;long&lt;/span&gt; ind;
  vec2D() {}
  vec2D(&lt;span class=&quot;synType&quot;&gt;double&lt;/span&gt; x, &lt;span class=&quot;synType&quot;&gt;double&lt;/span&gt; y,&lt;span class=&quot;synType&quot;&gt;long&lt;/span&gt; index) : x(x), y(y) ,ind(index) {} 
  vec2D &lt;span class=&quot;synStatement&quot;&gt;operator&lt;/span&gt; + (vec2D p){
	   &lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; vec2D(x + p.x, y + p.y,-&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;);
  }
  vec2D &lt;span class=&quot;synStatement&quot;&gt;operator&lt;/span&gt; - (vec2D p){
	   &lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; vec2D(x - p.x, y - p.y,-&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;);
  }
  vec2D &lt;span class=&quot;synStatement&quot;&gt;operator&lt;/span&gt; * (&lt;span class=&quot;synType&quot;&gt;double&lt;/span&gt; d){
	   &lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; vec2D(d*x, d*y,-&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;);
  }

  &lt;span class=&quot;synType&quot;&gt;double&lt;/span&gt; norm(&lt;span class=&quot;synType&quot;&gt;void&lt;/span&gt;){
  	&lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; sqrt(x*x + y*y);
  }

  &lt;span class=&quot;synType&quot;&gt;double&lt;/span&gt; twiceNorm(&lt;span class=&quot;synType&quot;&gt;void&lt;/span&gt;){
  	&lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; x*x + y*y;
  }

  &lt;span class=&quot;synType&quot;&gt;double&lt;/span&gt; dot(vec2D p){ &lt;span class=&quot;synComment&quot;&gt;//pとの内積&lt;/span&gt;
	   &lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; x * p.x + y * p.y;
  }
  &lt;span class=&quot;synType&quot;&gt;double&lt;/span&gt; det(vec2D p){ &lt;span class=&quot;synComment&quot;&gt;// (x,p)の行列式&lt;/span&gt;
	   &lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; x * p.y - p.x * y;
  }
  &lt;span class=&quot;synType&quot;&gt;double&lt;/span&gt; dist(vec2D p){ &lt;span class=&quot;synComment&quot;&gt;//pとの距離の2乗&lt;/span&gt;
	   &lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; (x-p.x)*(x-p.x) + (y-p.y)*(y-p.y);
  }
  &lt;span class=&quot;synType&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;operator&lt;/span&gt; &amp;lt;(&lt;span class=&quot;synType&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;struct&lt;/span&gt; vec2D &amp;amp;e) &lt;span class=&quot;synType&quot;&gt;const&lt;/span&gt;{
     &lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; x == e.x? (y &amp;lt; e.y) : x &amp;lt; e.x;
  }
  &lt;span class=&quot;synType&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;synStatement&quot;&gt;operator&lt;/span&gt; &amp;gt;(&lt;span class=&quot;synType&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;synType&quot;&gt;struct&lt;/span&gt; vec2D &amp;amp;e) &lt;span class=&quot;synType&quot;&gt;const&lt;/span&gt;{
     &lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; x == e.x? (y &amp;gt; e.y) : x &amp;gt; e.x;
  }
} pt;
&lt;/pre&gt;&lt;p&gt;次に、多角形クラスを定義しておく。これでまた凸包を求める問題が出ても怖くない !&lt;br /&gt;
なお、グラハムスキャンのところはほぼ蟻本写してます。&lt;/p&gt;
&lt;pre class=&quot;code lang-cpp&quot; data-lang=&quot;cpp&quot; data-unlink&gt;&lt;span class=&quot;synType&quot;&gt;bool&lt;/span&gt; cmp_x(&lt;span class=&quot;synType&quot;&gt;const&lt;/span&gt; pt &amp;amp;p1,&lt;span class=&quot;synType&quot;&gt;const&lt;/span&gt; pt &amp;amp;p2){ &lt;span class=&quot;synComment&quot;&gt;//ソート用の比較関数&lt;/span&gt;
	&lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; (p1.x != p2.x) &lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; p1.x &amp;lt; p2.x;
    &lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; p1.y &amp;lt; p2.y;
}
&lt;span class=&quot;synType&quot;&gt;class&lt;/span&gt; Polygon{
  &lt;span class=&quot;synStatement&quot;&gt;private&lt;/span&gt;:
    vector&amp;lt;pt&amp;gt; pts;
    &lt;span class=&quot;synType&quot;&gt;size_t&lt;/span&gt; n;
  &lt;span class=&quot;synStatement&quot;&gt;public&lt;/span&gt;:
    Polygon() : n(&lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;) {}
    Polygon(vector&amp;lt;pt&amp;gt; v) : n(v.size()) {
      pts = v;
    }

    &lt;span class=&quot;synType&quot;&gt;void&lt;/span&gt; addPoint(pt P){
      pts.push_back(P);
    }

    vector&amp;lt;pt&amp;gt; convexHull(&lt;span class=&quot;synType&quot;&gt;void&lt;/span&gt;){ &lt;span class=&quot;synComment&quot;&gt;// 凸包を構成する点の配列を返す。&lt;/span&gt;
      vector&amp;lt;pt&amp;gt; qs(n * &lt;span class=&quot;synConstant&quot;&gt;2&lt;/span&gt;);
      sort(pts.begin(),pts.end(),cmp_x);
      &lt;span class=&quot;synType&quot;&gt;long&lt;/span&gt; k = &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;;

      REP(i,n){ &lt;span class=&quot;synComment&quot;&gt;//下側凸包の作成&lt;/span&gt;
        &lt;span class=&quot;synStatement&quot;&gt;while&lt;/span&gt;(k &amp;gt; &lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt; &amp;amp;&amp;amp; (qs[k-&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;] - qs[k-&lt;span class=&quot;synConstant&quot;&gt;2&lt;/span&gt;]).det(pts[i] - qs[k-&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;]) &amp;lt;= &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;) k--;
        qs[k++] = pts[i];
      }

      &lt;span class=&quot;synStatement&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;synType&quot;&gt;long&lt;/span&gt; i = n - &lt;span class=&quot;synConstant&quot;&gt;2&lt;/span&gt;, t = k; i &amp;gt;= &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;; i--){ &lt;span class=&quot;synComment&quot;&gt;//上側凸包の作成&lt;/span&gt;
        &lt;span class=&quot;synStatement&quot;&gt;while&lt;/span&gt;(k &amp;gt; t &amp;amp;&amp;amp; (qs[k-&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;] - qs[k-&lt;span class=&quot;synConstant&quot;&gt;2&lt;/span&gt;]).det(pts[i] - qs[k-&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;]) &amp;lt;= &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;) k--;
        qs[k++] = pts[i];
      }
      qs.resize(k-&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;);
      n = k-&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;;
      pts = qs;
      &lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; qs;
    }
};
&lt;/pre&gt;&lt;p&gt;最後に、main関数を書く&lt;/p&gt;
&lt;pre class=&quot;code lang-cpp&quot; data-lang=&quot;cpp&quot; data-unlink&gt;&lt;span class=&quot;synType&quot;&gt;int&lt;/span&gt; main(&lt;span class=&quot;synType&quot;&gt;void&lt;/span&gt;){
	&lt;span class=&quot;synType&quot;&gt;short&lt;/span&gt; N;
	&lt;span class=&quot;synType&quot;&gt;double&lt;/span&gt; x,y;
	cin &amp;gt;&amp;gt; N;
	vector&amp;lt;pt&amp;gt; point,convex;

	REP(i,N) {
		cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
		point.push_back(pt(x,y,i));
	}

	&lt;span class=&quot;synStatement&quot;&gt;if&lt;/span&gt; (N == &lt;span class=&quot;synConstant&quot;&gt;2&lt;/span&gt;) { &lt;span class=&quot;synComment&quot;&gt;// コーナーケース&lt;/span&gt;
		cout &amp;lt;&amp;lt; &lt;span class=&quot;synConstant&quot;&gt;0.5&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;synSpecial&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;synConstant&quot;&gt;&amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;synConstant&quot;&gt;0.5&lt;/span&gt; &amp;lt;&amp;lt; endl;
		exit(&lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;);
	}

	Polygon P(point);
	convex = P.convexHull(); &lt;span class=&quot;synComment&quot;&gt;//凸包を求める&lt;/span&gt;
	vector&amp;lt;&lt;span class=&quot;synType&quot;&gt;double&lt;/span&gt;&amp;gt; ans(N,&lt;span class=&quot;synConstant&quot;&gt;0.0&lt;/span&gt;); &lt;span class=&quot;synComment&quot;&gt;//答えの確率を格納&lt;/span&gt;
	&lt;span class=&quot;synType&quot;&gt;long&lt;/span&gt; m = convex.size();

	&lt;span class=&quot;synType&quot;&gt;double&lt;/span&gt; alpha;
        &lt;span class=&quot;synComment&quot;&gt;// 角度を計算。&lt;/span&gt;
	REP(i,m-&lt;span class=&quot;synConstant&quot;&gt;2&lt;/span&gt;){&lt;span class=&quot;synComment&quot;&gt;//凸包の点1 ~ (m-2)までの確率を計算&lt;/span&gt;
		pt v1 = convex[i]-convex[i+&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;],v2 = convex[i+&lt;span class=&quot;synConstant&quot;&gt;2&lt;/span&gt;]-convex[i+&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;];
		alpha = acos((v1).dot(v2) / sqrt(v1.twiceNorm() * v2.twiceNorm()));
		ans[convex[i+&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;].ind] = (&lt;span class=&quot;synConstant&quot;&gt;M_PI&lt;/span&gt; - alpha)/ (&lt;span class=&quot;synConstant&quot;&gt;2&lt;/span&gt; * &lt;span class=&quot;synConstant&quot;&gt;M_PI&lt;/span&gt;);
	}
        &lt;span class=&quot;synComment&quot;&gt;// 凸包の点m-1の確率&lt;/span&gt;
	pt v1 = convex[m-&lt;span class=&quot;synConstant&quot;&gt;2&lt;/span&gt;] - convex[m-&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;],v2 = convex[&lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;] - convex[m-&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;];
	alpha = acos((v1).dot(v2) / sqrt(v1.twiceNorm() * v2.twiceNorm()));
	ans[convex[m-&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;].ind] = (&lt;span class=&quot;synConstant&quot;&gt;M_PI&lt;/span&gt; - alpha)/ (&lt;span class=&quot;synConstant&quot;&gt;2&lt;/span&gt; * &lt;span class=&quot;synConstant&quot;&gt;M_PI&lt;/span&gt;); 
        &lt;span class=&quot;synComment&quot;&gt;// 凸包の点0の確率&lt;/span&gt;
	v1 = convex[m-&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;] - convex[&lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;],v2 = convex[&lt;span class=&quot;synConstant&quot;&gt;1&lt;/span&gt;] - convex[&lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;];
	alpha = acos((v1).dot(v2) / sqrt(v1.twiceNorm() * v2.twiceNorm()));
	ans[convex[&lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;].ind] = (&lt;span class=&quot;synConstant&quot;&gt;M_PI&lt;/span&gt; - alpha)/ (&lt;span class=&quot;synConstant&quot;&gt;2&lt;/span&gt; * &lt;span class=&quot;synConstant&quot;&gt;M_PI&lt;/span&gt;);

	REP(i,N){
		cout &amp;lt;&amp;lt; ans[i] &amp;lt;&amp;lt; endl;
	}

	&lt;span class=&quot;synStatement&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;synConstant&quot;&gt;0&lt;/span&gt;;
}
&lt;/pre&gt;</content>        
        <category term="競技プログラミング" label="競技プログラミング" />
        
        <link rel="enclosure" href="http://chart.apis.google.com/chart?cht=tx&amp;chl=%28x%2Cy%29" type="" length="0" />

        <author>
            <name>banboooo</name>
        </author>
    </entry>
    
  
</feed>
